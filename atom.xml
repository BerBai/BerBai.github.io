<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tooyi.github.io</id>
    <title>涂诣</title>
    <updated>2020-05-27T00:49:22.986Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tooyi.github.io"/>
    <link rel="self" href="https://tooyi.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tooyi.github.io/images/avatar.png</logo>
    <icon>https://tooyi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 涂诣</rights>
    <entry>
        <title type="html"><![CDATA[Java 关于链表的基本算法]]></title>
        <id>https://tooyi.github.io/post/java-guan-yu-lian-biao-de-ji-ben-suan-fa/</id>
        <link href="https://tooyi.github.io/post/java-guan-yu-lian-biao-de-ji-ben-suan-fa/">
        </link>
        <updated>2020-05-27T00:47:26.000Z</updated>
        <summary type="html"><![CDATA[<p>算法代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法代码记录</p>
<!-- more -->
<pre><code class="language-java">import java.util.HashMap;
import java.util.Scanner;
import java.util.Stack;
 
/**
 * 
 * @author smartBBer
 * 关于java中链表的操作
 * 1. 求单链表中结点的个数: getListLength 
 * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） 
 * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode 
 * 4. 查找单链表的中间结点: getMiddleNode 
 * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） 
 * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec 
 * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入）
 * 8. 判断一个单链表中是否有环: hasCycle 
 * 9. 判断两个单链表是否相交: isIntersect 
 * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap 
 * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode
 */
public class LinkedListSummary {
	/**
	 * @param args
	 * 
	 */
	public static class Node{
		int value;
		Node next;
		public Node(int n){
			this.value=n;
			this.next=null;
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in=new Scanner(System.in);
		Node head=null;
		if(in.hasNextInt()){
			head=new Node(in.nextInt());
		}
		Node temp=head;
		while(in.hasNextInt()){
			temp.next=new Node(in.nextInt());
			temp=temp.next;
		}
		in.close();
		//int len=getListLength(head);
		//Node reHead=reverseList(head);
		//reHead=reverseListRec(reHead);
		//Node node_k=reGetKthNode(head,3);
		//Node mid=getMiddleNode(head);
		//reversePrintListRec(head);
		//reversePrintListStack(head);
		//Node mergeHead=mergeSortedList(head,null);
		//Node sortHead=listSort(head);
		
	}
	//求单链表中结点的个数: getListLength 
	public static int getListLength(Node head){
		int len=0;
		while(head!=null){
			len++;
			head=head.next;
		}
		return len;
	}
	//将单链表反转,循环
	public static Node reverseList(Node head){
		if(head==null||head.next==null)return head;
		Node pre=null;
		Node nex=null;
		while(head!=null){
			nex=head.next;
			head.next=pre;
			pre=head;
			head=nex;
		}
		return pre;
	}
	//将单链表反转,递归
	public static Node reverseListRec(Node head){
		if(head==null||head.next==null)return head;
		Node reHead=reverseListRec(head.next);
		head.next.next=head;
		head.next=null;
		return reHead;
	}
	//查找单链表中的倒数第K个结点（k &gt; 0）
	public static Node reGetKthNode(Node head,int k){
		if(head==null)return head;
		int len=getListLength(head);
		if(k&gt;len)return null;
		Node target=head;
		Node nexk=head;
		for(int i=0;i&lt;k;i++){
			nexk=nexk.next;
		}
		while(nexk!=null){
			target=target.next;
			nexk=nexk.next;
		}
		return target;
	}
	//查找单链表的中间结点 
	public static Node getMiddleNode(Node head){
		if(head==null||head.next==null)return head;
		Node target=head;
		Node temp=head;
		while(temp!=null&amp;&amp;temp.next!=null){
			target=target.next;
			temp=temp.next.next;
		}
		return target;
	}
	//从尾到头打印单链表,递归
	public static void reversePrintListRec(Node head){
		if(head==null)return;
		else{
			reversePrintListRec(head.next);
			System.out.println(head.value);
		}
	}
	//从尾到头打印单链表,栈
	public static void reversePrintListStack(Node head){
		Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();
		while(head!=null){
			s.push(head);
			head=head.next;
		}
		while(!s.isEmpty()){
			System.out.println(s.pop().value);
		}
	}
	//合并两个有序的单链表head1和head2，循环
	public static Node mergeSortedList(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		Node target=null;
		if(head1.value&gt;head2.value){
			target=head2;
			head2=head2.next;
		}
		else{
			target=head1;
			head1=head1.next;
		}
		target.next=null;
		Node mergeHead=target;
		while(head1!=null &amp;&amp; head2!=null){
			if(head1.value&gt;head2.value){
				target.next=head2;
				head2=head2.next;
			}
			else{
				target.next=head1;
				head1=head1.next;
			}
			target=target.next;
			target.next=null;
		}
		if(head1==null)target.next=head2;
		else target.next=head1;
		return mergeHead;
	}
	//合并两个有序的单链表head1和head2，递归
	public static Node mergeSortedListRec(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		if(head1.value&gt;head2.value){
			head2.next=mergeSortedListRec(head2.next,head1);
			return head2;
		}
		else{
			head1.next=mergeSortedListRec(head1.next,head2);
			return head1;
		}
	}
	//对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出
	public static Node listSort(Node head){
		Node nex=null;
		if(head==null||head.next==null)return head;
		else if(head.next.next==null){
			nex=head.next;
			head.next=null;
		}
		else{
			Node mid=getMiddleNode(head);
			nex=mid.next;
			mid.next=null;
		}
		return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归
	}
	//对单链表进行排序,插入排序
	public Node insertionSortList(Node head) {
        if(head==null||head.next==null)return head;
        Node pnex=head.next;
        Node pnex_nex=null;
        head.next=null;
        while(pnex!=null){
            pnex_nex=pnex.next;
            Node temp=head;
            Node temp_pre=null;
            while(temp!=null){
                if(temp.value&gt;pnex.value)break;
                temp_pre=temp;
                temp=temp.next;
            }
            if(temp_pre==null){
                head=pnex;
                pnex.next=temp;
            }
            else{
                temp_pre.next=pnex;
                pnex.next=temp;
            }
            pnex=pnex_nex;
        }
        return head;
    }
	//判断一个单链表中是否有环,快慢指针
	public static boolean hasCycle(Node head){
		boolean flag=false;
		Node p1=head;
		Node p2=head;
		while(p1!=null&amp;&amp;p2!=null){
			p1=p1.next;
			p2=p2.next.next;
			if(p2==p1){
				flag=true;
				break;
			}
		}
		return flag;
	}
	//判断两个单链表是否相交,如果相交返回第一个节点，否则返回null
	//如果单纯的判断是否相交，只需要看最后一个指针是否相等
	public static Node isIntersect(Node head1,Node head2){
		Node target=null;
		if(head1==null||head2==null)return target;
		int len1=getListLength(head1);
		int len2=getListLength(head2);
		if(len1&gt;=len2){
			for(int i=0;i&lt;len1-len2;i++){
				head1=head1.next;
			}
		}else{
			for(int i=0;i&lt;len2-len1;i++){
				head2=head2.next;
			}
		}
		while(head1!=null&amp;&amp;head2!=null){
			if(head1==head2){
				target=head1;
				break;
			}
			else{
				head1=head1.next;
				head2=head2.next;
			}
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高
	public static Node getFirstNodeInCycleHashMap(Node head){
		Node target=null;
		HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;();
		while(head!=null){
			if(map.containsKey(head)) {
                target=head;
                break;
            }
			else{
				map.put(head, true);
			}
			head=head.next;
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap
	//用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
	public static Node getFirstNodeInCycle(Node head){
		Node fast=head;
		Node slow=head;
		while(fast!=null&amp;&amp;fast.next!=null){
			slow=slow.next;
			fast=fast.next.next;
			if(slow==fast)
                break;
		}
		if(fast==null||fast.next==null)return null;//判断是否包含环
		//相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
		slow=head;
		while(slow!=fast){
			slow=slow.next;
			fast=fast.next;
		}//同步走
		return slow;
		
	}
	//给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete
	//可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1)
	public static void deleteNode(Node head,Node delete){
		//首先处理delete节点为最后一个节点的情况
		if(delete==null)return;
		if(delete.next==null){
			if(head==delete)head=null;
			else{
				Node temp=head;
				while(temp.next!=delete){
					temp=temp.next;
				}
				temp.next=null;
			}
		}
		else{
			delete.value=delete.next.value;
			delete.next=delete.next.next;
		}
		return;
	}
}
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Visual Studio Code 使用技巧]]></title>
        <id>https://tooyi.github.io/post/visual-studio-code/</id>
        <link href="https://tooyi.github.io/post/visual-studio-code/">
        </link>
        <updated>2020-05-27T00:28:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="visual-studio-code-使用技巧">Visual Studio Code 使用技巧</h1>
<h2 id="一窗口打开多项目">一窗口打开多项目</h2>
<blockquote>
<p>文件 -&gt; 将文件添加到工作区</p>
</blockquote>
<p>添加多个文件项目即可</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/tooyi/picBox/master/img/006KCUaNgy1fvo94f9915j307c09174e.jpg" alt="工作区" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[换一个新主题 - Gridea Themes Vant]]></title>
        <id>https://tooyi.github.io/post/hello-gridea/</id>
        <link href="https://tooyi.github.io/post/hello-gridea/">
        </link>
        <updated>2020-05-26T11:00:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="访问旧博客">访问旧博客</h2>
<p><strong>新博客使用Gridea管理，旧博客文章暂时未全部搬运。若访问旧博客，请访问</strong><a href="https://tooyi.github.io/blog-old/">涂诣的官方网站</a></p>
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="访问旧博客">访问旧博客</h2>
<p><strong>新博客使用Gridea管理，旧博客文章暂时未全部搬运。若访问旧博客，请访问</strong><a href="https://tooyi.github.io/blog-old/">涂诣的官方网站</a></p>
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 关于链表的基本算法]]></title>
        <id>https://tooyi.github.io/post/java-suan-fa/</id>
        <link href="https://tooyi.github.io/post/java-suan-fa/">
        </link>
        <updated>2019-12-23T00:47:26.000Z</updated>
        <summary type="html"><![CDATA[<p>算法代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法代码记录</p>
<!-- more -->
<pre><code class="language-java">import java.util.HashMap;
import java.util.Scanner;
import java.util.Stack;
 
/**
 * 
 * @author smartBBer
 * 关于java中链表的操作
 * 1. 求单链表中结点的个数: getListLength 
 * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） 
 * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode 
 * 4. 查找单链表的中间结点: getMiddleNode 
 * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） 
 * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec 
 * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入）
 * 8. 判断一个单链表中是否有环: hasCycle 
 * 9. 判断两个单链表是否相交: isIntersect 
 * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap 
 * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode
 */
public class LinkedListSummary {
	/**
	 * @param args
	 * 
	 */
	public static class Node{
		int value;
		Node next;
		public Node(int n){
			this.value=n;
			this.next=null;
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in=new Scanner(System.in);
		Node head=null;
		if(in.hasNextInt()){
			head=new Node(in.nextInt());
		}
		Node temp=head;
		while(in.hasNextInt()){
			temp.next=new Node(in.nextInt());
			temp=temp.next;
		}
		in.close();
		//int len=getListLength(head);
		//Node reHead=reverseList(head);
		//reHead=reverseListRec(reHead);
		//Node node_k=reGetKthNode(head,3);
		//Node mid=getMiddleNode(head);
		//reversePrintListRec(head);
		//reversePrintListStack(head);
		//Node mergeHead=mergeSortedList(head,null);
		//Node sortHead=listSort(head);
		
	}
	//求单链表中结点的个数: getListLength 
	public static int getListLength(Node head){
		int len=0;
		while(head!=null){
			len++;
			head=head.next;
		}
		return len;
	}
	//将单链表反转,循环
	public static Node reverseList(Node head){
		if(head==null||head.next==null)return head;
		Node pre=null;
		Node nex=null;
		while(head!=null){
			nex=head.next;
			head.next=pre;
			pre=head;
			head=nex;
		}
		return pre;
	}
	//将单链表反转,递归
	public static Node reverseListRec(Node head){
		if(head==null||head.next==null)return head;
		Node reHead=reverseListRec(head.next);
		head.next.next=head;
		head.next=null;
		return reHead;
	}
	//查找单链表中的倒数第K个结点（k &gt; 0）
	public static Node reGetKthNode(Node head,int k){
		if(head==null)return head;
		int len=getListLength(head);
		if(k&gt;len)return null;
		Node target=head;
		Node nexk=head;
		for(int i=0;i&lt;k;i++){
			nexk=nexk.next;
		}
		while(nexk!=null){
			target=target.next;
			nexk=nexk.next;
		}
		return target;
	}
	//查找单链表的中间结点 
	public static Node getMiddleNode(Node head){
		if(head==null||head.next==null)return head;
		Node target=head;
		Node temp=head;
		while(temp!=null&amp;&amp;temp.next!=null){
			target=target.next;
			temp=temp.next.next;
		}
		return target;
	}
	//从尾到头打印单链表,递归
	public static void reversePrintListRec(Node head){
		if(head==null)return;
		else{
			reversePrintListRec(head.next);
			System.out.println(head.value);
		}
	}
	//从尾到头打印单链表,栈
	public static void reversePrintListStack(Node head){
		Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();
		while(head!=null){
			s.push(head);
			head=head.next;
		}
		while(!s.isEmpty()){
			System.out.println(s.pop().value);
		}
	}
	//合并两个有序的单链表head1和head2，循环
	public static Node mergeSortedList(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		Node target=null;
		if(head1.value&gt;head2.value){
			target=head2;
			head2=head2.next;
		}
		else{
			target=head1;
			head1=head1.next;
		}
		target.next=null;
		Node mergeHead=target;
		while(head1!=null &amp;&amp; head2!=null){
			if(head1.value&gt;head2.value){
				target.next=head2;
				head2=head2.next;
			}
			else{
				target.next=head1;
				head1=head1.next;
			}
			target=target.next;
			target.next=null;
		}
		if(head1==null)target.next=head2;
		else target.next=head1;
		return mergeHead;
	}
	//合并两个有序的单链表head1和head2，递归
	public static Node mergeSortedListRec(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		if(head1.value&gt;head2.value){
			head2.next=mergeSortedListRec(head2.next,head1);
			return head2;
		}
		else{
			head1.next=mergeSortedListRec(head1.next,head2);
			return head1;
		}
	}
	//对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出
	public static Node listSort(Node head){
		Node nex=null;
		if(head==null||head.next==null)return head;
		else if(head.next.next==null){
			nex=head.next;
			head.next=null;
		}
		else{
			Node mid=getMiddleNode(head);
			nex=mid.next;
			mid.next=null;
		}
		return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归
	}
	//对单链表进行排序,插入排序
	public Node insertionSortList(Node head) {
        if(head==null||head.next==null)return head;
        Node pnex=head.next;
        Node pnex_nex=null;
        head.next=null;
        while(pnex!=null){
            pnex_nex=pnex.next;
            Node temp=head;
            Node temp_pre=null;
            while(temp!=null){
                if(temp.value&gt;pnex.value)break;
                temp_pre=temp;
                temp=temp.next;
            }
            if(temp_pre==null){
                head=pnex;
                pnex.next=temp;
            }
            else{
                temp_pre.next=pnex;
                pnex.next=temp;
            }
            pnex=pnex_nex;
        }
        return head;
    }
	//判断一个单链表中是否有环,快慢指针
	public static boolean hasCycle(Node head){
		boolean flag=false;
		Node p1=head;
		Node p2=head;
		while(p1!=null&amp;&amp;p2!=null){
			p1=p1.next;
			p2=p2.next.next;
			if(p2==p1){
				flag=true;
				break;
			}
		}
		return flag;
	}
	//判断两个单链表是否相交,如果相交返回第一个节点，否则返回null
	//如果单纯的判断是否相交，只需要看最后一个指针是否相等
	public static Node isIntersect(Node head1,Node head2){
		Node target=null;
		if(head1==null||head2==null)return target;
		int len1=getListLength(head1);
		int len2=getListLength(head2);
		if(len1&gt;=len2){
			for(int i=0;i&lt;len1-len2;i++){
				head1=head1.next;
			}
		}else{
			for(int i=0;i&lt;len2-len1;i++){
				head2=head2.next;
			}
		}
		while(head1!=null&amp;&amp;head2!=null){
			if(head1==head2){
				target=head1;
				break;
			}
			else{
				head1=head1.next;
				head2=head2.next;
			}
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高
	public static Node getFirstNodeInCycleHashMap(Node head){
		Node target=null;
		HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;();
		while(head!=null){
			if(map.containsKey(head)) {
                target=head;
                break;
            }
			else{
				map.put(head, true);
			}
			head=head.next;
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap
	//用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
	public static Node getFirstNodeInCycle(Node head){
		Node fast=head;
		Node slow=head;
		while(fast!=null&amp;&amp;fast.next!=null){
			slow=slow.next;
			fast=fast.next.next;
			if(slow==fast)
                break;
		}
		if(fast==null||fast.next==null)return null;//判断是否包含环
		//相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
		slow=head;
		while(slow!=fast){
			slow=slow.next;
			fast=fast.next;
		}//同步走
		return slow;
		
	}
	//给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete
	//可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1)
	public static void deleteNode(Node head,Node delete){
		//首先处理delete节点为最后一个节点的情况
		if(delete==null)return;
		if(delete.next==null){
			if(head==delete)head=null;
			else{
				Node temp=head;
				while(temp.next!=delete){
					temp=temp.next;
				}
				temp.next=null;
			}
		}
		else{
			delete.value=delete.next.value;
			delete.next=delete.next.next;
		}
		return;
	}
}
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eclipse 调教]]></title>
        <id>https://tooyi.github.io/post/eclipse-diao-jiao/</id>
        <link href="https://tooyi.github.io/post/eclipse-diao-jiao/">
        </link>
        <updated>2018-10-27T00:44:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="版本对比">版本对比</h2>
<p>如果不知道安装什么版本，可以选择 Java EE 版本安装。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmq8pmmm1j30un0h5gop.jpg" alt="Eclipse 个版本对比" loading="lazy"></figure>
<h2 id="常用配置设置">常用配置设置</h2>
<p>以下为梓涵自用配置设置，可供参考。</p>
<h3 id="设置-utf-8-编码">设置 UTF-8 编码</h3>
<p>设置 UTF-8 编码方式，中文才可以正常显示。</p>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; workspace中text file encoding改为utf-8</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqb0g13uj30lp0jlgpp.jpg" alt="设置UTF-8" loading="lazy"></figure>
<h3 id="设置国际化资源编码">设置国际化资源编码</h3>
<p>设置properties文件编码。</p>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; Content Types —&gt; Text —&gt; Java Properties File选中，然后下面default encoding改为 utf-8</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqgdpm0rj30lp0jl77e.jpg" alt="国际化编码设置" loading="lazy"></figure>
<h3 id="设置jsp编码">设置jsp编码</h3>
<p>设置为 UTF-8 编码，不然显示页面可能出现乱码。</p>
<ul>
<li>window -&gt; preferences -&gt; web -&gt; jsp files中 encoding 改为 utf-8</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqjx8e2nj30lp0jltaw.jpg" alt="jsp文件编码方式" loading="lazy"></figure>
<h2 id="优化文本编辑器显示">优化文本编辑器显示</h2>
<p>让界面交互更直观。</p>
<h3 id="显示行号显示空白字符">显示行号，显示空白字符</h3>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; editor -&gt; text editors -&gt; show line numbers show whitespace characters ，然后点击configure visibility 设置如下图。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqqvhck3j30lp0kb784.jpg" alt="显示行号和空白字符" loading="lazy"></figure>
<h3 id="调整编辑器字体和大小">调整编辑器字体和大小</h3>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; appearance -&gt; colors and fonts，在点开 Basic 、 Java 等下，找到 Text Font 字样，在选择 Edit 进行调整。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmr22b3wsj30lp0kbn0a.jpg" alt="设置字体" loading="lazy"></figure>
<h3 id="设置java默认风格每行最大字符数量">设置java默认风格每行最大字符数量</h3>
<p>在使用ctrl + shift + f格式化java代码时，经常会遇到换行的问题，默认风格一行最大为80个字符，</p>
<ul>
<li>window -&gt; preferences -&gt; java -&gt; code style -&gt; formatter -&gt; edit... -&gt; line wrapping -&gt; maximum line width 可以根据需要修改.</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmrepii6tj30lp0kb0wk.jpg" alt="最大行显示数" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java框架总结]]></title>
        <id>https://tooyi.github.io/post/java-zong-jie/</id>
        <link href="https://tooyi.github.io/post/java-zong-jie/">
        </link>
        <updated>2018-10-12T00:42:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java框架总结">Java框架总结</h2>
<p>使用SpringMVC + Spring + Mybatis （SSM）框架</p>
<p>使用Struts2 + Spring + Hibernate （SSH）框架</p>
<p>相当于 页面 -&gt; Servlet -&gt; Java（接口类） -&gt; JDBC -&gt; 数据库</p>
<p>SpringPost</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/tooyi/picBox/master/img/006KCUaNgy1fwaf90g4snj311h0kvwhn.jpg" alt="图示" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2018/10/16/5bc5f2cb2ac77.jpg" alt="SSM SSH框架总结.jpg" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="3"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web前端助手(FeHelper)]]></title>
        <id>https://tooyi.github.io/post/web-fehelper/</id>
        <link href="https://tooyi.github.io/post/web-fehelper/">
        </link>
        <updated>2018-10-02T00:38:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="web前端助手fehelper">Web前端助手(FeHelper)</h2>
<h3 id="获取地址">获取地址：</h3>
<p><a href="https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad">Chrome扩展商城</a></p>
<p><a href="https://github.com/zxlie/FeHelper/tree/master/apps/static/screenshot/crx">国内地址</a></p>
<h3 id="安装方法">安装方法</h3>
<p>Chrome扩展商城下载不需要看此方法。</p>
<p>下载当前最新版*.crx；</p>
<p>chrome浏览器地址栏输入：chrome://extensions/ 并打开；</p>
<p>右上角开启开发者模式；</p>
<p>拖拽crx到当前页面，完成安装。</p>
<h3 id="功能简介">功能简介</h3>
<h4 id="fehelper-弹出菜单">FeHelper--弹出菜单</h4>
<p>插件入口，点击ICON，插件相关的所有功能都会在这里列出来，在popup中选择所需使用的功能即可使用</p>
<h4 id="json接口自动格式化查看">JSON接口自动格式化查看</h4>
<p>当你访问的接口（打开的页面）返回的是一个JSON格式的数据，FeHelper会自动将内容进行格式化处理，便于您的查看</p>
<h4 id="json查看器">JSON查看器</h4>
<p>把你的JSON代码粘贴到JSON查看器的输入框中，点击“格式化”，在下方便会以非常友好的方式列出JSON数据，便于查看</p>
<h4 id="代码美化">代码美化</h4>
<p>包括Javascript代码美化、CSS代码美化、HTML代码美化；其实所有C系的代码，都可以通过Javascript代码美化工具进行格式化查看</p>
<h4 id="代码压缩">代码压缩</h4>
<p>包括Web前端Javascript代码压缩、CSS代码压缩、HTML代码压缩</p>
<h4 id="字符串编解码">字符串编解码</h4>
<p>包括Unicode编码和解码、UTF-8字符串编码和解码、Base64字符串编解码、字符串MD5编码，前端非常实用的工具</p>
<h4 id="图片base64编码">图片Base64编码</h4>
<p>对图片文件进行base64编码，直接拷贝datauri格式的数据</p>
<h4 id="二维码生成器">二维码生成器</h4>
<p>能对网址、普通文本内容、电话号码、通讯录、短信等编码并生成二维码，很实用的二维码生成工具</p>
<h4 id="二维码解码">二维码解码</h4>
<p>针对网页上的二维码，点击右键，选择【二维码解码】，可在当前页面直接看到解码结果！</p>
<h4 id="全网页截图">全网页截图</h4>
<p>针对整个网页进行滚动截屏，在新窗口可预览后再手动保存</p>
<h4 id="时间戳转换工具">时间（戳）转换工具</h4>
<p>支持任意时间到对应时间戳的转换；支持任意时间戳到对应日期的转换</p>
<h4 id="正则表达式工具">正则表达式工具</h4>
<p>提供一个正则表达式的及时测试工具，并能将匹配结果进行高亮显示、高亮定位等；同时还罗列了一些常用的正则表达式供开发者使用</p>
<h4 id="页面取色工具">页面取色工具</h4>
<p>提供一个网页取色的工具，任意页面均可使用，方便大家在开发过程中能精准获取某元素的颜色值，再也不用截图后再通过Photoshop取色了</p>
<h4 id="编码规范检测">编码规范检测</h4>
<p>对当前网页进行Javascript、CSS、HTML编码规范的检测，包括文件是否压缩、标签是否正确闭合、cookie管理等等</p>
<h4 id="页面性能检测">页面性能检测</h4>
<p>对当前页面的性能进行检测，如HTTP响应时间、页面渲染时间、是否启用gzip压缩等等</p>
<h4 id="fehelper配置页">FeHelper配置页</h4>
<p>在这里，你可以随意定制属于你自己的FeHelper常用功能！</p>
<h3 id="关注我的微信公众号">关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/10/13/5bc1d8c55f18a.png" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Visual Studio Code 主题及插件推荐]]></title>
        <id>https://tooyi.github.io/post/visual-studio/</id>
        <link href="https://tooyi.github.io/post/visual-studio/">
        </link>
        <updated>2018-09-25T13:55:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="visual-studio-code-主题及插件推荐">Visual Studio Code 主题及插件推荐</h1>
<h2 id="主题">主题</h2>
<p>One Dark Pro</p>
<p>Atom One Dark Theme</p>
<p>Eva Theme</p>
<h2 id="插件">插件</h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peek">CSS Peek</a>： html和css中关联css的跳转</p>
<h3 id="快捷键">快捷键</h3>
<ul>
<li><code>F12</code>：跳转 css 文件，jump directly to the css file or open it in a new editor</li>
<li><code>Ctrl+Shift+F12</code>： load the css file inline and make quick edits right there.</li>
<li><code>Ctrl+hover</code>：show the definition in a hover over the symbol</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序开发]]></title>
        <id>https://tooyi.github.io/post/wechat3/</id>
        <link href="https://tooyi.github.io/post/wechat3/">
        </link>
        <updated>2018-09-25T00:23:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="微信小程序开发">微信小程序开发</h1>
<h2 id="小程序文档">小程序文档</h2>
<p>注册账号、代码构成、小程序上线等请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/">官方文档</a></p>
<h2 id="ide选择">IDE选择</h2>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18092022">官方开发工具</a></p>
<p><a href="">VScode + wept</a></p>
<p><a href="https://egret.com/products/wing.html">Egret Wing</a></p>
<table>
<thead>
<tr>
<th>环境</th>
<th>简述</th>
<th>代码高亮</th>
<th>代码提示</th>
<th>调试</th>
<th>实时预览</th>
<th>软件/插件下载</th>
</tr>
</thead>
<tbody>
<tr>
<td>官方工具</td>
<td>微信小程序官方工具</td>
<td>支持</td>
<td>极其弱</td>
<td>支持</td>
<td>支持</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18092022">软件</a></td>
</tr>
<tr>
<td>Egret Wing</td>
<td>首款支持微信小程序开发的IDE</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td><a href="https://egret.com/products/wing.html">软件</a></td>
</tr>
<tr>
<td>VScode + wept</td>
<td>插件作者已不在维护</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td><a href="https://chemzqm.github.io/wept/#/">插件</a></td>
</tr>
<tr>
<td>Sublime Text 3</td>
<td>代码编辑器，需要安装插件</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td><a href="https://github.com/Abbotton/weapp-snippet-for-sublime-text-2-3">插件</a></td>
</tr>
<tr>
<td>WebStorm</td>
<td>重量级IDE</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td><a href="https://github.com/lypeer/Matchmaker">插件</a></td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/tooyi/picBox/master/img/006KCUaNgy1fvm5h0v6uej30rs06x0sy.jpg" alt="IDE对比" loading="lazy"></figure>
<h2 id="小程序组件">小程序组件</h2>
<h3 id="weui">Weui</h3>
<p>WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。包含 button、cell、dialog、 progress、 toast、article、actionsheet、icon 等各式元素。</p>
<p>GitHub 地址：<a href="https://github.com/Tencent/Weui">Weui</a></p>
<p>演示：<a href="https://weui.io">https://weui.io</a></p>
<h3 id="wx-charts">wx-charts</h3>
<p>微信小程序图表工具，charts for WeChat small app</p>
<p>基于 canvas 绘制，体积小巧</p>
<p>GitHub 地址：<a href="https://github.com/xiaolin3303/wx-charts">wx-charts</a></p>
<p><img src="https://ws1.sinaimg.cn/large/006KCUaNgy1fvn52y1somj30b409tt93.jpg" alt="饼图" loading="lazy"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn53s02c0j30b408djrf.jpg" alt="环图" loading="lazy"></p>
<h3 id="wemark">wemark</h3>
<p>微信小程序 Markdown 渲染库</p>
<p>用于在小程序中渲染 Markdown 文本。</p>
<p>在小程序诞生之前，Markdown 的渲染一般需要解析成HTML，然后渲染解析后的 HTML。然而小程序并没有提供 HTML 渲染的功能，因此在 wemark 诞生之前，几乎所有的 Markdown 渲染库全部无法在小程序下正常工作。</p>
<p>wemark可以实现在小程序下渲染Markdown内容，支持图片、表格在内的大部分Markdown特性。</p>
<figure data-type="image" tabindex="2"><img src="https://github.com/TooBug/wemark/blob/2.0/screenshot.png" alt="示例图" loading="lazy"></figure>
<h3 id="wezrender">WeZRender</h3>
<p>微信小程序 Canvas 开发</p>
<h4 id="使用-zrender-实现">使用 ZRender 实现</h4>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn4rb938zg308v0fwhdt.gif" alt="演示图" loading="lazy"></figure>
<p>ZRender 是二维绘图引擎，它提供 Canvas、SVG、VML 等多种渲染方式。ZRender 也是 ECharts 的渲染器。</p>
<p>GitHub 地址：<a href="https://github.com/guyoung/WeZRender/tree/master/apps/zrenderapp">ZRender 实现</a></p>
<h4 id="使用-echarts-实现">使用 ECharts 实现</h4>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn4w0xf8rg308w0fre81.gif" alt="演示图" loading="lazy"></figure>
<p>ECharts 是使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器，底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p>
<p>GitHub地址：<a href="https://github.com/guyoung/WeZRender/tree/master/apps/echartsapp">ECharts 实现</a></p>
<h3 id="wetoast">WeToast</h3>
<p>WeToast 是仿照微信小程序提供的 showToast 功能，提供视觉一致的增强插件，弥补小程序showToast功能上的不足（如只能显示 success、loading 两种 icon ，且 icon 不可去除，持续时间最大10秒等）。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn5bzacxoj308t0fqdfr.jpg" alt="演示图" loading="lazy"></figure>
<p>GitHub 地址：<a href="https://github.com/kiinlam/wetoast">WeToast</a></p>
<h3 id="wxapp-charts">wxapp-charts</h3>
<p>微信小程序图表charts组件</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn5hn32khj309e0go0t8.jpg" alt="演示图" loading="lazy"></figure>
<h3 id="weixinproject">WeiXinProject</h3>
<p>微信小程序实现--列表的上拉刷新和上拉加载</p>
<p>GitHub 地址：<a href="https://github.com/lidong1665/WeiXinProject">WeiXinProject</a></p>
<h3 id="cityselect">citySelect</h3>
<p>基于微信小程序的城市选择</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvn5q4oevpj30k00zkt9k.jpg" alt="演示图" loading="lazy"></figure>
<h2 id="小程序框架">小程序框架</h2>
<h3 id="wepy">Wepy</h3>
<blockquote>
<p>微信小程序组件化开发框架</p>
</blockquote>
<p>通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async Functions的引入都是为了能让开发小程序项目变得更加简单，高效。</p>
<p>GitHub 地址：<a href="https://github.com/tencent/wepy">Wepy</a></p>
<p>体验：<a href="https://tencent.github.io/wepy/">https://tencent.github.io/wepy/</a></p>
<h3 id="labrador">Labrador</h3>
<p>微信小程序组件化开发框架</p>
<p>GitHub 地址：<a href="https://github.com/maichong/labrador">Labrador</a></p>
<h3 id="wxapp-devframe">wxapp-devFrame</h3>
<p>小程序基本的开发框架抽取</p>
<p>GitHub 地址：<a href="https://github.com/hss01248/wxapp-devFrame">wxapp-devFrame</a></p>
<h3 id="westore">Westore</h3>
<p>受 <a href="https://github.com/Tencent/omi">Omi</a> 框架 的启发，且专门为小程序开发的 <a href="https://github.com/dntzhang/westore/blob/master/utils/diff.js">JSON Diff 库</a>，所以有了 westore 全局状态管理和跨页通讯框架让一切尽在掌握中，且受高性能 JSON Diff 库的利好，长列表滚动加载显示变得轻松可驾驭。总结下来有如下特性和优势:</p>
<ul>
<li>和 Omi 同样简洁的 Store API</li>
<li>超小的代码尺寸(包括 json diff 共100多行)</li>
<li>尊重且顺从小程序的设计(其他转译库相当于反其道行)</li>
<li>this.update 比原生 setData 的性能更优，更加智能</li>
</ul>
<p>GitHub地址：<a href="https://github.com/dntzhang/westore">westore</a></p>
<h2 id="库">库</h2>
<h3 id="wxparse">wxParse</h3>
<p>wxParse-微信小程序富文本解析自定义组件，支持HTML及markdown解析</p>
<p>GitHub 地址：<a href="https://github.com/icindy/wxParse">wxParse</a></p>
<h3 id="wechat-weapp-redux">wechat-weapp-redux</h3>
<p>微信小程序 Redux 绑定，用于在微信小程序为页面绑定 Redux Store。</p>
<p>代码是基于 <a href="https://github.com/reduxjs/react-redux">react-redux</a> 修改的</p>
<p>GitHub 地址：<a href="https://github.com/charleyw/wechat-weapp-redux">wechat-weapp-redux</a></p>
<h3 id="wilddog-weapp">wilddog-weapp</h3>
<p>野狗微信小程序客户SDK</p>
<blockquote>
<p>野狗是什么?</p>
</blockquote>
<blockquote>
<p>野狗科技(北京)有限公司（简称：野狗）是安全可靠的实时通信云。野狗为企业和开发者提供了可编程的实时数据、音视频通信能力，以及短信服务，可以安全地构建丰富场景化的实时通信业务。</p>
</blockquote>
<p>GitHub 地址：<a href="https://github.com/WildDogTeam/wilddog-weapp">wilddog-weapp</a></p>
<h3 id="wafer-client-sdk">wafer-client-sdk</h3>
<p>本项目是 <a href="https://github.com/tencentyun/wafer">Wafer</a> 的组成部分，为小程序客户端开发提供 SDK 支持会话服务和信道服务。</p>
<p>GitHub 地址：<a href="https://github.com/tencentyun/wafer-client-sdk">wafer-client-sdk</a></p>
<h3 id="wxnotificationcenter">WxNotificationCenter</h3>
<p>微信小程序通知广播模式类,降低小程序之间的耦合度</p>
<p>GitHub 地址：<a href="https://github.com/icindy/WxNotificationCenter">WxNotificationCenter</a></p>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[下载微信图文中的视频]]></title>
        <id>https://tooyi.github.io/post/wechat2/</id>
        <link href="https://tooyi.github.io/post/wechat2/">
        </link>
        <updated>2018-09-23T13:53:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="下载微信图文中的视频">下载微信图文中的视频</h2>
<h5 id="摘要">摘要</h5>
<p>在有的时候我们需要下载公众号中的视频，那么我们怎么才能下载呢？在网上搜索了下，发现很多都是抓包获取的，没有好的方法，干脆就自己动手了。</p>
<h5 id="动手">动手</h5>
<ul>
<li>首先得明白，微信图文中的视频都是挂在腾讯视频上的，所以视频的 url 肯定是以 v.qq.com 开头的；</li>
<li>用浏览器打开微信图文，这里使用的是 Chrome 浏览器；</li>
<li>查看源码，点击鼠标右键，选择查看源码；</li>
<li>搜索关键字，<code>Ctrl + F</code> ，输入 v.qq.com ，即可找到视频的 url 地址；</li>
</ul>
<pre><code>  https://v.qq.com/iframe/preview.html?vid=z0191d2jue3&amp;amp;width=500&amp;amp;height=375&amp;amp;auto=0
</code></pre>
<ul>
<li>
<p>复制视频 url 地址到新窗口打开，如下图</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvjupqp197j30es0but9z.jpg" alt="视频获取" loading="lazy"></figure>
</li>
</ul>
<p>之后有两种方法将视频保存至本地</p>
<h6 id="idm下载">IDM下载</h6>
<ul>
<li>
<p>安装过 IDM 的，在浏览器中会有一个 IDM浮窗 很方便就可以下载，同时视频播放前的广告也会被 IDM 捕捉，下载时看清楚即可。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvjurm5m21j30iy0jbtaq.jpg" alt="IDM浮窗" loading="lazy"></figure>
</li>
</ul>
<h6 id="抓包">抓包</h6>
<ul>
<li>
<p>在之前的视频界面按 <code>F12</code> 打开浏览器的控制台，选择 <code>Network</code> ，播放视频，在右边栏找到视频地址即可。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fvjus8qpisj311y0jh41r.jpg" alt="视频直链" loading="lazy"></figure>
<pre><code>http://ugcbsy.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/z0191d2jue3.mp4?vkey=1CF07F9A6D07BCB2FC5C39D356208A957BD7DEFCD45E02078B70734FC6CF286D021A589AA2D1ECD86F533A44981AF98A36C72DD27E408504D008FDC9552D50FC1D53DFA7BA9BD3D6328DD26D34869FD34F87778711FF8282ECB5AD5428FB21C91B0B15F28017F4F45867291B1BF43D30423A52A90E4A0180&amp;br=60&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v5010&amp;guid=f0902504c2c6838dddc832e651ea45bf
</code></pre>
</li>
<li>
<p>复制视频地址，至浏览器中打开，待视频显示出来点击鼠标右键保存即可。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>