<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tooyi.github.io</id>
    <title>涂诣</title>
    <updated>2020-05-27T01:02:23.648Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tooyi.github.io"/>
    <link rel="self" href="https://tooyi.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tooyi.github.io/images/avatar.png</logo>
    <icon>https://tooyi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 涂诣</rights>
    <entry>
        <title type="html"><![CDATA[换一个新主题 - Gridea Themes Vant]]></title>
        <id>https://tooyi.github.io/post/hello-gridea/</id>
        <link href="https://tooyi.github.io/post/hello-gridea/">
        </link>
        <updated>2020-05-26T11:00:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="访问旧博客">访问旧博客</h2>
<p><strong>新博客使用Gridea管理，旧博客文章暂时未全部搬运。若访问旧博客，请访问</strong><a href="https://tooyi.github.io/blog-old/">涂诣的官方网站</a></p>
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="访问旧博客">访问旧博客</h2>
<p><strong>新博客使用Gridea管理，旧博客文章暂时未全部搬运。若访问旧博客，请访问</strong><a href="https://tooyi.github.io/blog-old/">涂诣的官方网站</a></p>
<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序---flex布局]]></title>
        <id>https://tooyi.github.io/post/wei-xin-xiao-cheng-xu-flex-bu-ju/</id>
        <link href="https://tooyi.github.io/post/wei-xin-xiao-cheng-xu-flex-bu-ju/">
        </link>
        <updated>2019-02-16T00:59:35.000Z</updated>
        <summary type="html"><![CDATA[<p>代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>代码记录</p>
<!-- more -->
<h2 id="微信小程序-flex布局">微信小程序---flex布局</h2>
<h3 id="基础代码">基础代码</h3>
<pre><code class="language-html">&lt;!-- .wxml --&gt;
&lt;view class='container'&gt;
  &lt;view class='chunk color1'&gt;1&lt;/view&gt;
  &lt;view class='chunk color2'&gt;2&lt;/view&gt;
  &lt;view class='chunk color3'&gt;3&lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="language-css">/* .wxss */
.chunk{
  height: 100px;
  width: 100px;
}
.container {
  height: 400px;
  background: #898989;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<h3 id="view-组件">view 组件</h3>
<p>使用 view 组件时，默认是<strong>列向</strong>排列</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08b6atmocj30af0ih0st.jpg" alt="默认view布局" loading="lazy"></figure>
<h4 id="view-组件更改排列方向">view 组件更改排列方向</h4>
<ol>
<li>display: inline;</li>
</ol>
<p>使用 display: inline; 可以实现横向排列，但是<strong>不能设置高度和宽度</strong>，代码中虽然设置，但是无作用。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08bkji2uqj30af0ih74b.jpg" alt="display: inline;" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/* 增加 display: inline; */
.chunk{
  height: 100px;
  width: 100px;
  display: inline;
}
.container {
  height: 400px;
  background: #898989;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<ol start="2">
<li>display: inline-block;</li>
</ol>
<p>inline-block 可以设置高度和宽度。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08blqsls0j30af0iit8q.jpg" alt="display: inline-block;" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/* 增加 display: inline-block; */
.chunk{
  height: 100px;
  width: 100px;
  display: inline-block;
}
.container {
  height: 400px;
  background: #898989;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<h3 id="flex">flex</h3>
<p>而当使用 flex 布局时，默认是<strong>横向</strong>排列</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08bc0r8eoj30af0ifdfq.jpg" alt="flex默认布局" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/* 使用flex布局 */
.chunk{
  height: 100px;
  width: 100px;
}
.container {
  height: 400px;
  display: flex;
  background: #898989;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<h4 id="更改排列方向">更改排列方向</h4>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08bt0zmt6j30af0i73yl.jpg" alt="flex-direction: column;" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/* flex-direction: row; 实现行内排列， column实现列内排列*/
.chunk{
  height: 100px;
  width: 100px;
}
.container {
  height: 400px;
  display: flex;
  background: #898989;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<p>使用 flex 布局还有一个方便实现的功能 ————实现 view 组件的倒序排列<br>
只需要加一个 flex-direction: row-reverse;</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08c5qhavgj30af0ieq30.jpg" alt="flex-direction: row-reverse;" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/* flex-direction: row-reverse;  实现行内倒序排列 column-reverse;*/
.chunk{
  height: 100px;
  width: 100px;
}
.container {
  height: 400px;
  display: flex;
  background: #898989;
  flex-direction: column-reverse;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<p>这时候发现一个问题，现在是从底部开始排列的，想要在顶部开始排列，加上 justify-content: flex-end;</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1g08c8wxg6pj30af0ijjrh.jpg" alt="justify-content: flex-end;" loading="lazy"></figure>
<pre><code class="language-css">/* .wxss */
/*   justify-content: flex-end;*/
/* justify-content: space-between; 平均分布  center 剧中分布  space-around 等距分布 */
.chunk{
  height: 100px;
  width: 100px;
}
.container {
  height: 400px;
  display: flex;
  background: #898989;
  flex-direction: column-reverse;
  justify-content: flex-end;
}
.color1{
  background-color: red;
}
.color2{
  background-color: blue;
}
.color3{
  background-color: pink;
}
</code></pre>
<p>这时仔细的你发现，flex-end 不是应该是从底部开始排列的？</p>
<p>再仔细的你就会发现，前面加入了 flex-direction: column-reverse; 反转了一下，所以 flex-end 就变成 flex-start 的效果了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[json格式化插件]]></title>
        <id>https://tooyi.github.io/post/json-ge-shi-hua-cha-jian/</id>
        <link href="https://tooyi.github.io/post/json-ge-shi-hua-cha-jian/">
        </link>
        <updated>2019-01-23T00:57:33.000Z</updated>
        <summary type="html"><![CDATA[<p>chrome浏览器-json格式化插件</p>
]]></summary>
        <content type="html"><![CDATA[<p>chrome浏览器-json格式化插件</p>
<!-- more -->
<h3 id="第一步">第一步</h3>
<p>下载json 的JSON-Handle插件：地址：<a href="http://jsonhandle.sinaapp.com/">http://jsonhandle.sinaapp.com/</a></p>
<h3 id="第二步">第二步</h3>
<p>打开浏览器—&gt;右键点击三个点—&gt;更多工具—&gt;扩展程序—&gt;将crx插件拖入浏览器</p>
<h3 id="这时候你运行你的程序">这时候你运行你的程序</h3>
<p>出现以下结果说明已经成功安装成功。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fzgln4pwpaj313g0vgmzq.jpg" alt="效果图" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[摩尔投票算法]]></title>
        <id>https://tooyi.github.io/post/mo-er-tou-piao-suan-fa/</id>
        <link href="https://tooyi.github.io/post/mo-er-tou-piao-suan-fa/">
        </link>
        <updated>2019-01-04T00:55:35.000Z</updated>
        <summary type="html"><![CDATA[<p>摩尔投票算法理解记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>摩尔投票算法理解记录</p>
<!-- more -->
<h3 id="摩尔投票算法">摩尔投票算法</h3>
<blockquote>
<p>摩尔投票算法也可以叫做多数投票算法。</p>
</blockquote>
<h3 id="题">题</h3>
<blockquote>
<p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br>
你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
</blockquote>
<ul>
<li>示例 1:</li>
</ul>
<p><code>输入: [3,2,3]</code><br>
<code>输出: 3</code></p>
<ul>
<li>示例 2:</li>
</ul>
<p><code>输入: [2,2,1,1,1,2,2]</code><br>
<code>输出: 2</code></p>
<h3 id="常规解法">常规解法</h3>
<ul>
<li>遍历数组，并计数，找出出现次数大于 ⌊ n/2 ⌋ 的元素。</li>
<li>将数组排序，出现次数大于 ⌊ n/2 ⌋ 的元素必定在数组中间，返回nums[n/2]即可。</li>
</ul>
<h3 id="摩尔投票法求解">摩尔投票法求解</h3>
<blockquote>
<p>算法的时间和空间都很低，时间复杂度为O(n)，空间复杂度为O(1)</p>
</blockquote>
<h4 id="算法原理">算法原理</h4>
<p>每次从数组中找出一对不同的元素，将它们从数组中删除，直到遍历完整个数组。由于这道题已经说明一定存在一个出现次数超过一半的元素，所以遍历完数组后数组中一定会存在至少一个元素。</p>
<ul>
<li>算法在局部变量中定义一个序列元素(m)和一个计数器(count)，初始化的情况下计数器为1；</li>
<li>算法依次扫描序列中的元素，当处理元素x的时候，如果序列元素(m)和x相等，计数器(count)自增1；</li>
<li>如果不等计数器(count)自减1，并判断计数器是否为0，如果为0，那么将x赋值给m，然后将计数器(count)设置为1(或将x的下一位元素赋值给m，计数器(count)设为0)；</li>
<li>处理之后，最后存储的序列元素(m)，就是这个序列中最多的元素。<br>
（如果不确定是否存储的元素m是最多的元素，还可以进行第二遍扫描判断是否为最多的元素）</li>
</ul>
<h4 id="伪码实现">伪码实现</h4>
<pre><code class="language-java">初始化元素m=nums[0],计数器count=1;
for i = 1 : nums.length - 1
    if m = nums[i]
        count++
    else 
        count--
        if count = 0
            m = numd[i + 1]
            count = 0
return m
</code></pre>
<h4 id="java实现">java实现</h4>
<pre><code class="language-java">class Solution {
    public int majorityElement(int[] nums) {
        int count = 1, maj = nums[0];
        for(int i = 1; i &lt; nums.length; i++) {
            if(maj == nums[i]) { 
                count++;
            } else {
                count--;
                if(count == 0) {
                    maj = nums[i + 1];
                    count = 0;
                }
            }
            
        }
        return maj;
    }
}
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 字符串常用类]]></title>
        <id>https://tooyi.github.io/post/java-zi-fu-chuan-chang-yong-lei/</id>
        <link href="https://tooyi.github.io/post/java-zi-fu-chuan-chang-yong-lei/">
        </link>
        <updated>2018-12-23T00:49:42.000Z</updated>
        <summary type="html"><![CDATA[<p>字符串知识总结</p>
]]></summary>
        <content type="html"><![CDATA[<p>字符串知识总结</p>
<!-- more -->
<h2 id="字符串查找">字符串查找</h2>
<p>String 提供了两种查找字符串的方法，即 <strong>indexOf</strong> 与 <strong>lastIndexOf</strong> 方法。</p>
<h3 id="1-indexofstring-s">1、indexOf（String s）</h3>
<p>该方法用于返回参数字符串s在指定字符串中首次出现的索引位置，当调用字符串的indexOf()方法时，会从当前字符串的开始位置搜索s的位置；如果没有检索到字符串s，该方法返回-1</p>
<pre><code class="language-java">String str =&quot;We are students&quot;;
int size = str.indexOf(&quot;a&quot;); // 变量size的值是3
</code></pre>
<h3 id="2-lastindexofstring-str">2、lastIndexOf(String str)</h3>
<p>该方法用于返回字符串最后一次出现的索引位置。当调用字符串的lastIndexOf()方法时，会从当前字符串的开始位置检索参数字符串str，并将最后一次出现str的索引位置返回。如果没有检索到字符串str，该方法返回-1.</p>
<p>如果lastIndexOf方法中的参数是空字符串&quot;&quot; ，，则返回的结果与length方法的返回结果相同。</p>
<h2 id="获取指定索引位置的字符">获取指定索引位置的字符</h2>
<p>使用charAt()方法可将指定索引处的字符返回。</p>
<pre><code class="language-java">String str = &quot;hello word&quot;;
char mychar =  str.charAt(4);  // mychar的结果是o
</code></pre>
<h2 id="获取子字符串">获取子字符串</h2>
<p>通过String类的substring()方法可对字符串进行截取。这些方法的共同点就是都利用字符串的下标进行截取，且应明确字符串下标是从0开始的。在字符串中空格占用一个索引位置。</p>
<h3 id="1-substringint-beginindex">1、substring(int beginIndex)</h3>
<p>该方法返回的是从指定的索引位置开始截取知道该字符串结尾的子串。</p>
<pre><code class="language-java">String str = &quot;Hello word&quot;;
String substr = str.substring(3); //获取字符串，此时substr值为lo word
</code></pre>
<h3 id="2-substringint-beginindex-int-endindex">2、substring(int beginIndex,  int endIndex)</h3>
<p>beginIndex : 开始截取子字符串的索引位置</p>
<p>endIndex：子字符串在整个字符串中的结束位置</p>
<pre><code class="language-java">String str = &quot;Hello word&quot;;
String substr = str.substring(0,3); //substr的值为hel
</code></pre>
<h2 id="去除空格-标点等">去除空格、标点等</h2>
<p>trim() 方法返回字符串的副本，忽略前导空格和尾部空格。</p>
<pre><code class="language-java">public static void main(String[] args) {
        //string去除空格
        String str=&quot;  hello   world  &quot;;
        System.out.println(str);
 
        String str1=str.trim();//去除首尾空格
        System.out.println(str1);
 
        String str2=str.replace(&quot; &quot;,&quot;&quot;);//去掉所有空格,包括首尾,中间
        System.out.println(str2);
 
        String str3=str.replaceAll(&quot; +&quot;,&quot;&quot;);//去掉所有空格,包括首尾,中间
        System.out.println(str3);
 
        String str4=str.replaceAll(&quot;\\s*&quot;,&quot;&quot;); //可以替换大部分空白字符， 不限于空格 . 说明:\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个
        System.out.println(str4);
 
        //string去除标点符号
        //正则表达式去除标点
        String stri=&quot;ss&amp;*(,.~1如果@&amp;(^-自己!!知道`什`么#是$苦%……Z，&amp;那*()么一-=定——+告诉::;\&quot;'/?.,&gt;&lt;[]{}\\||别人什么是甜。&quot;;
        System.out.println(stri);
 
        String stri1=stri.replaceAll(&quot;\\p{Punct}&quot;,&quot;&quot;);//不能完全清除标点
        System.out.println(stri1);
 
        String stri2=stri.replaceAll(&quot;\\pP&quot;,&quot;&quot;);//完全清除标点
        System.out.println(stri2);
 
        String stri3=stri.replaceAll(&quot;\\p{P}&quot;,&quot;&quot;);//同上,一样的功能
        System.out.println(stri3);
 
        String stri4=stri.replaceAll(&quot;[\\pP\\p{Punct}]&quot;,&quot;&quot;);//清除所有符号,只留下字母 数字  汉字  共3类.
        System.out.println(stri4);
    }
}
</code></pre>
<pre><code>//**效果如下**
hello   world  
hello   world
helloworld
helloworld
helloworld
ss&amp;*(,.~1如果@&amp;(^-自己!!知道`什`么#是$苦%……Z，&amp;那*()么一-=定——+告诉::;&quot;'/?.,&gt;&lt;[]{}\||别人什么是甜。
ss1如果自己知道什么是苦……Z，那么一定——告诉别人什么是甜。
ss~1如果^自己知道`什`么是$苦Z那么一=定+告诉&gt;&lt;||别人什么是甜
ss~1如果^自己知道`什`么是$苦Z那么一=定+告诉&gt;&lt;||别人什么是甜
ss1如果自己知道什么是苦Z那么一定告诉别人什么是甜
</code></pre>
<h2 id="字符串替换">字符串替换</h2>
<p>replace(w) 方法可实现将指定的字符或字符串替换成新的字符或字符串</p>
<p>oldChar：要替换的字符或字符串</p>
<p>newChar：用于替换原来字符串的内容</p>
<p>如果要替换的字符oldChar在字符串中重复出现多次，replace()方法会将所有oldChar全部替换成newChar。需要注意的是，要替换的字符oldChar的大小写要与原字符串中字符的大小写保持一致。</p>
<pre><code class="language-java">String str= &quot;address&quot;;
String newstr = str.replace(&quot;a&quot;, &quot;A&quot;);// newstr的值为Address
</code></pre>
<h2 id="判断字符串的开始与结尾">判断字符串的开始与结尾</h2>
<p>startsWith()方法与endsWith()方法分别用于判断字符串是否以指定的内容开始或结束。这两个方法的返回值都为boolean类型。</p>
<h3 id="1-startswithstring-prefix">1、startsWith(String prefix)</h3>
<p>该方法用于判断当前字符串对象的前缀是否是参数指定的字符串。</p>
<h3 id="2-endswithstring-suffix">2、endsWith(String suffix)</h3>
<p>该方法用于判断当前字符串是否以给定的子字符串结束</p>
<h2 id="判断字符串是否相等">判断字符串是否相等</h2>
<h3 id="1-equalsstring-otherstr">1、equals(String otherstr)</h3>
<p>如果两个字符串具有相同的字符和长度，则使用equals()方法比较时，返回true。同时equals()方法比较时区分大小写。</p>
<h3 id="2-equalsignorecasestring-otherstr">2、equalsIgnoreCase(String otherstr)</h3>
<p>equalsIgnoreCase()方法与equals()类型，不过在比较时<strong>忽略了大小写</strong>。</p>
<h2 id="按字典顺序比较两个字符串">按字典顺序比较两个字符串</h2>
<p>compareTo()方法为按字典顺序比较两个字符串，该比较基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果按字典顺序此String对象位于参数字符串之前，则比较结果为一个负整数；如果按字典顺序此String对象位于参数字符串之后，则比较结果为一个正整数；如果这两个字符串相等，则结果为0.</p>
<pre><code class="language-java">str.compareTo(String otherstr);
</code></pre>
<h2 id="字母大小写转换">字母大小写转换</h2>
<p>字符串的toLowerCase()方法可将字符串中的所有字符从大写字母改写为小写字母，而tuUpperCase()方法可将字符串中的小写字母改写为大写字母。</p>
<pre><code class="language-java">str.toLowerCase();
str.toUpperCase();
</code></pre>
<h2 id="字符串分割">字符串分割</h2>
<p>使用split()方法可以使字符串按指定的分隔字符或字符串对内容进行分割，并将分割后的结果存放在字符数组中。</p>
<pre><code class="language-java">1 str.split(String sign);
</code></pre>
<p>sign为分割字符串的分割符，也可以使用正则表达式。</p>
<p>没有统一的对字符串进行分割的符号，如果想定义多个分割符，可使用符号“<kbd>|</kbd>”。例如，“,<kbd>|</kbd>=”表示分割符分别为“,”和“=”。</p>
<pre><code class="language-java">str.split(String sign, in limit);
</code></pre>
<p>该方法可根据给定的分割符对字符串进行拆分，并限定拆分的次数。</p>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 关于链表的基本算法]]></title>
        <id>https://tooyi.github.io/post/java-guan-yu-lian-biao-de-ji-ben-suan-fa/</id>
        <link href="https://tooyi.github.io/post/java-guan-yu-lian-biao-de-ji-ben-suan-fa/">
        </link>
        <updated>2018-12-23T00:47:26.000Z</updated>
        <summary type="html"><![CDATA[<p>算法代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法代码记录</p>
<!-- more -->
<pre><code class="language-java">import java.util.HashMap;
import java.util.Scanner;
import java.util.Stack;
 
/**
 * 
 * @author smartBBer
 * 关于java中链表的操作
 * 1. 求单链表中结点的个数: getListLength 
 * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） 
 * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode 
 * 4. 查找单链表的中间结点: getMiddleNode 
 * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） 
 * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec 
 * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入）
 * 8. 判断一个单链表中是否有环: hasCycle 
 * 9. 判断两个单链表是否相交: isIntersect 
 * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap 
 * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode
 */
public class LinkedListSummary {
	/**
	 * @param args
	 * 
	 */
	public static class Node{
		int value;
		Node next;
		public Node(int n){
			this.value=n;
			this.next=null;
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in=new Scanner(System.in);
		Node head=null;
		if(in.hasNextInt()){
			head=new Node(in.nextInt());
		}
		Node temp=head;
		while(in.hasNextInt()){
			temp.next=new Node(in.nextInt());
			temp=temp.next;
		}
		in.close();
		//int len=getListLength(head);
		//Node reHead=reverseList(head);
		//reHead=reverseListRec(reHead);
		//Node node_k=reGetKthNode(head,3);
		//Node mid=getMiddleNode(head);
		//reversePrintListRec(head);
		//reversePrintListStack(head);
		//Node mergeHead=mergeSortedList(head,null);
		//Node sortHead=listSort(head);
		
	}
	//求单链表中结点的个数: getListLength 
	public static int getListLength(Node head){
		int len=0;
		while(head!=null){
			len++;
			head=head.next;
		}
		return len;
	}
	//将单链表反转,循环
	public static Node reverseList(Node head){
		if(head==null||head.next==null)return head;
		Node pre=null;
		Node nex=null;
		while(head!=null){
			nex=head.next;
			head.next=pre;
			pre=head;
			head=nex;
		}
		return pre;
	}
	//将单链表反转,递归
	public static Node reverseListRec(Node head){
		if(head==null||head.next==null)return head;
		Node reHead=reverseListRec(head.next);
		head.next.next=head;
		head.next=null;
		return reHead;
	}
	//查找单链表中的倒数第K个结点（k &gt; 0）
	public static Node reGetKthNode(Node head,int k){
		if(head==null)return head;
		int len=getListLength(head);
		if(k&gt;len)return null;
		Node target=head;
		Node nexk=head;
		for(int i=0;i&lt;k;i++){
			nexk=nexk.next;
		}
		while(nexk!=null){
			target=target.next;
			nexk=nexk.next;
		}
		return target;
	}
	//查找单链表的中间结点 
	public static Node getMiddleNode(Node head){
		if(head==null||head.next==null)return head;
		Node target=head;
		Node temp=head;
		while(temp!=null&amp;&amp;temp.next!=null){
			target=target.next;
			temp=temp.next.next;
		}
		return target;
	}
	//从尾到头打印单链表,递归
	public static void reversePrintListRec(Node head){
		if(head==null)return;
		else{
			reversePrintListRec(head.next);
			System.out.println(head.value);
		}
	}
	//从尾到头打印单链表,栈
	public static void reversePrintListStack(Node head){
		Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();
		while(head!=null){
			s.push(head);
			head=head.next;
		}
		while(!s.isEmpty()){
			System.out.println(s.pop().value);
		}
	}
	//合并两个有序的单链表head1和head2，循环
	public static Node mergeSortedList(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		Node target=null;
		if(head1.value&gt;head2.value){
			target=head2;
			head2=head2.next;
		}
		else{
			target=head1;
			head1=head1.next;
		}
		target.next=null;
		Node mergeHead=target;
		while(head1!=null &amp;&amp; head2!=null){
			if(head1.value&gt;head2.value){
				target.next=head2;
				head2=head2.next;
			}
			else{
				target.next=head1;
				head1=head1.next;
			}
			target=target.next;
			target.next=null;
		}
		if(head1==null)target.next=head2;
		else target.next=head1;
		return mergeHead;
	}
	//合并两个有序的单链表head1和head2，递归
	public static Node mergeSortedListRec(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		if(head1.value&gt;head2.value){
			head2.next=mergeSortedListRec(head2.next,head1);
			return head2;
		}
		else{
			head1.next=mergeSortedListRec(head1.next,head2);
			return head1;
		}
	}
	//对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出
	public static Node listSort(Node head){
		Node nex=null;
		if(head==null||head.next==null)return head;
		else if(head.next.next==null){
			nex=head.next;
			head.next=null;
		}
		else{
			Node mid=getMiddleNode(head);
			nex=mid.next;
			mid.next=null;
		}
		return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归
	}
	//对单链表进行排序,插入排序
	public Node insertionSortList(Node head) {
        if(head==null||head.next==null)return head;
        Node pnex=head.next;
        Node pnex_nex=null;
        head.next=null;
        while(pnex!=null){
            pnex_nex=pnex.next;
            Node temp=head;
            Node temp_pre=null;
            while(temp!=null){
                if(temp.value&gt;pnex.value)break;
                temp_pre=temp;
                temp=temp.next;
            }
            if(temp_pre==null){
                head=pnex;
                pnex.next=temp;
            }
            else{
                temp_pre.next=pnex;
                pnex.next=temp;
            }
            pnex=pnex_nex;
        }
        return head;
    }
	//判断一个单链表中是否有环,快慢指针
	public static boolean hasCycle(Node head){
		boolean flag=false;
		Node p1=head;
		Node p2=head;
		while(p1!=null&amp;&amp;p2!=null){
			p1=p1.next;
			p2=p2.next.next;
			if(p2==p1){
				flag=true;
				break;
			}
		}
		return flag;
	}
	//判断两个单链表是否相交,如果相交返回第一个节点，否则返回null
	//如果单纯的判断是否相交，只需要看最后一个指针是否相等
	public static Node isIntersect(Node head1,Node head2){
		Node target=null;
		if(head1==null||head2==null)return target;
		int len1=getListLength(head1);
		int len2=getListLength(head2);
		if(len1&gt;=len2){
			for(int i=0;i&lt;len1-len2;i++){
				head1=head1.next;
			}
		}else{
			for(int i=0;i&lt;len2-len1;i++){
				head2=head2.next;
			}
		}
		while(head1!=null&amp;&amp;head2!=null){
			if(head1==head2){
				target=head1;
				break;
			}
			else{
				head1=head1.next;
				head2=head2.next;
			}
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高
	public static Node getFirstNodeInCycleHashMap(Node head){
		Node target=null;
		HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;();
		while(head!=null){
			if(map.containsKey(head)) {
                target=head;
                break;
            }
			else{
				map.put(head, true);
			}
			head=head.next;
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap
	//用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
	public static Node getFirstNodeInCycle(Node head){
		Node fast=head;
		Node slow=head;
		while(fast!=null&amp;&amp;fast.next!=null){
			slow=slow.next;
			fast=fast.next.next;
			if(slow==fast)
                break;
		}
		if(fast==null||fast.next==null)return null;//判断是否包含环
		//相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
		slow=head;
		while(slow!=fast){
			slow=slow.next;
			fast=fast.next;
		}//同步走
		return slow;
		
	}
	//给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete
	//可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1)
	public static void deleteNode(Node head,Node delete){
		//首先处理delete节点为最后一个节点的情况
		if(delete==null)return;
		if(delete.next==null){
			if(head==delete)head=null;
			else{
				Node temp=head;
				while(temp.next!=delete){
					temp=temp.next;
				}
				temp.next=null;
			}
		}
		else{
			delete.value=delete.next.value;
			delete.next=delete.next.next;
		}
		return;
	}
}
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 关于链表的基本算法]]></title>
        <id>https://tooyi.github.io/post/java-suan-fa/</id>
        <link href="https://tooyi.github.io/post/java-suan-fa/">
        </link>
        <updated>2018-12-23T00:47:26.000Z</updated>
        <summary type="html"><![CDATA[<p>算法代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法代码记录</p>
<!-- more -->
<pre><code class="language-java">import java.util.HashMap;
import java.util.Scanner;
import java.util.Stack;
 
/**
 * 
 * @author smartBBer
 * 关于java中链表的操作
 * 1. 求单链表中结点的个数: getListLength 
 * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） 
 * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode 
 * 4. 查找单链表的中间结点: getMiddleNode 
 * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） 
 * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec 
 * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入）
 * 8. 判断一个单链表中是否有环: hasCycle 
 * 9. 判断两个单链表是否相交: isIntersect 
 * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap 
 * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode
 */
public class LinkedListSummary {
	/**
	 * @param args
	 * 
	 */
	public static class Node{
		int value;
		Node next;
		public Node(int n){
			this.value=n;
			this.next=null;
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in=new Scanner(System.in);
		Node head=null;
		if(in.hasNextInt()){
			head=new Node(in.nextInt());
		}
		Node temp=head;
		while(in.hasNextInt()){
			temp.next=new Node(in.nextInt());
			temp=temp.next;
		}
		in.close();
		//int len=getListLength(head);
		//Node reHead=reverseList(head);
		//reHead=reverseListRec(reHead);
		//Node node_k=reGetKthNode(head,3);
		//Node mid=getMiddleNode(head);
		//reversePrintListRec(head);
		//reversePrintListStack(head);
		//Node mergeHead=mergeSortedList(head,null);
		//Node sortHead=listSort(head);
		
	}
	//求单链表中结点的个数: getListLength 
	public static int getListLength(Node head){
		int len=0;
		while(head!=null){
			len++;
			head=head.next;
		}
		return len;
	}
	//将单链表反转,循环
	public static Node reverseList(Node head){
		if(head==null||head.next==null)return head;
		Node pre=null;
		Node nex=null;
		while(head!=null){
			nex=head.next;
			head.next=pre;
			pre=head;
			head=nex;
		}
		return pre;
	}
	//将单链表反转,递归
	public static Node reverseListRec(Node head){
		if(head==null||head.next==null)return head;
		Node reHead=reverseListRec(head.next);
		head.next.next=head;
		head.next=null;
		return reHead;
	}
	//查找单链表中的倒数第K个结点（k &gt; 0）
	public static Node reGetKthNode(Node head,int k){
		if(head==null)return head;
		int len=getListLength(head);
		if(k&gt;len)return null;
		Node target=head;
		Node nexk=head;
		for(int i=0;i&lt;k;i++){
			nexk=nexk.next;
		}
		while(nexk!=null){
			target=target.next;
			nexk=nexk.next;
		}
		return target;
	}
	//查找单链表的中间结点 
	public static Node getMiddleNode(Node head){
		if(head==null||head.next==null)return head;
		Node target=head;
		Node temp=head;
		while(temp!=null&amp;&amp;temp.next!=null){
			target=target.next;
			temp=temp.next.next;
		}
		return target;
	}
	//从尾到头打印单链表,递归
	public static void reversePrintListRec(Node head){
		if(head==null)return;
		else{
			reversePrintListRec(head.next);
			System.out.println(head.value);
		}
	}
	//从尾到头打印单链表,栈
	public static void reversePrintListStack(Node head){
		Stack&lt;Node&gt; s=new Stack&lt;Node&gt;();
		while(head!=null){
			s.push(head);
			head=head.next;
		}
		while(!s.isEmpty()){
			System.out.println(s.pop().value);
		}
	}
	//合并两个有序的单链表head1和head2，循环
	public static Node mergeSortedList(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		Node target=null;
		if(head1.value&gt;head2.value){
			target=head2;
			head2=head2.next;
		}
		else{
			target=head1;
			head1=head1.next;
		}
		target.next=null;
		Node mergeHead=target;
		while(head1!=null &amp;&amp; head2!=null){
			if(head1.value&gt;head2.value){
				target.next=head2;
				head2=head2.next;
			}
			else{
				target.next=head1;
				head1=head1.next;
			}
			target=target.next;
			target.next=null;
		}
		if(head1==null)target.next=head2;
		else target.next=head1;
		return mergeHead;
	}
	//合并两个有序的单链表head1和head2，递归
	public static Node mergeSortedListRec(Node head1,Node head2){
		if(head1==null)return head2;
		if(head2==null)return head1;
		if(head1.value&gt;head2.value){
			head2.next=mergeSortedListRec(head2.next,head1);
			return head2;
		}
		else{
			head1.next=mergeSortedListRec(head1.next,head2);
			return head1;
		}
	}
	//对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出
	public static Node listSort(Node head){
		Node nex=null;
		if(head==null||head.next==null)return head;
		else if(head.next.next==null){
			nex=head.next;
			head.next=null;
		}
		else{
			Node mid=getMiddleNode(head);
			nex=mid.next;
			mid.next=null;
		}
		return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归
	}
	//对单链表进行排序,插入排序
	public Node insertionSortList(Node head) {
        if(head==null||head.next==null)return head;
        Node pnex=head.next;
        Node pnex_nex=null;
        head.next=null;
        while(pnex!=null){
            pnex_nex=pnex.next;
            Node temp=head;
            Node temp_pre=null;
            while(temp!=null){
                if(temp.value&gt;pnex.value)break;
                temp_pre=temp;
                temp=temp.next;
            }
            if(temp_pre==null){
                head=pnex;
                pnex.next=temp;
            }
            else{
                temp_pre.next=pnex;
                pnex.next=temp;
            }
            pnex=pnex_nex;
        }
        return head;
    }
	//判断一个单链表中是否有环,快慢指针
	public static boolean hasCycle(Node head){
		boolean flag=false;
		Node p1=head;
		Node p2=head;
		while(p1!=null&amp;&amp;p2!=null){
			p1=p1.next;
			p2=p2.next.next;
			if(p2==p1){
				flag=true;
				break;
			}
		}
		return flag;
	}
	//判断两个单链表是否相交,如果相交返回第一个节点，否则返回null
	//如果单纯的判断是否相交，只需要看最后一个指针是否相等
	public static Node isIntersect(Node head1,Node head2){
		Node target=null;
		if(head1==null||head2==null)return target;
		int len1=getListLength(head1);
		int len2=getListLength(head2);
		if(len1&gt;=len2){
			for(int i=0;i&lt;len1-len2;i++){
				head1=head1.next;
			}
		}else{
			for(int i=0;i&lt;len2-len1;i++){
				head2=head2.next;
			}
		}
		while(head1!=null&amp;&amp;head2!=null){
			if(head1==head2){
				target=head1;
				break;
			}
			else{
				head1=head1.next;
				head2=head2.next;
			}
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高
	public static Node getFirstNodeInCycleHashMap(Node head){
		Node target=null;
		HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;();
		while(head!=null){
			if(map.containsKey(head)) {
                target=head;
                break;
            }
			else{
				map.put(head, true);
			}
			head=head.next;
		}
		return target;
	}
	//已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap
	//用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
	public static Node getFirstNodeInCycle(Node head){
		Node fast=head;
		Node slow=head;
		while(fast!=null&amp;&amp;fast.next!=null){
			slow=slow.next;
			fast=fast.next.next;
			if(slow==fast)
                break;
		}
		if(fast==null||fast.next==null)return null;//判断是否包含环
		//相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等
		slow=head;
		while(slow!=fast){
			slow=slow.next;
			fast=fast.next;
		}//同步走
		return slow;
		
	}
	//给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete
	//可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1)
	public static void deleteNode(Node head,Node delete){
		//首先处理delete节点为最后一个节点的情况
		if(delete==null)return;
		if(delete.next==null){
			if(head==delete)head=null;
			else{
				Node temp=head;
				while(temp.next!=delete){
					temp=temp.next;
				}
				temp.next=null;
			}
		}
		else{
			delete.value=delete.next.value;
			delete.next=delete.next.next;
		}
		return;
	}
}
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Eclipse 调教]]></title>
        <id>https://tooyi.github.io/post/eclipse-diao-jiao/</id>
        <link href="https://tooyi.github.io/post/eclipse-diao-jiao/">
        </link>
        <updated>2018-10-27T00:44:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="版本对比">版本对比</h2>
<p>如果不知道安装什么版本，可以选择 Java EE 版本安装。</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmq8pmmm1j30un0h5gop.jpg" alt="Eclipse 个版本对比" loading="lazy"></figure>
<h2 id="常用配置设置">常用配置设置</h2>
<p>以下为梓涵自用配置设置，可供参考。</p>
<h3 id="设置-utf-8-编码">设置 UTF-8 编码</h3>
<p>设置 UTF-8 编码方式，中文才可以正常显示。</p>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; workspace中text file encoding改为utf-8</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqb0g13uj30lp0jlgpp.jpg" alt="设置UTF-8" loading="lazy"></figure>
<h3 id="设置国际化资源编码">设置国际化资源编码</h3>
<p>设置properties文件编码。</p>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; Content Types —&gt; Text —&gt; Java Properties File选中，然后下面default encoding改为 utf-8</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqgdpm0rj30lp0jl77e.jpg" alt="国际化编码设置" loading="lazy"></figure>
<h3 id="设置jsp编码">设置jsp编码</h3>
<p>设置为 UTF-8 编码，不然显示页面可能出现乱码。</p>
<ul>
<li>window -&gt; preferences -&gt; web -&gt; jsp files中 encoding 改为 utf-8</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqjx8e2nj30lp0jltaw.jpg" alt="jsp文件编码方式" loading="lazy"></figure>
<h2 id="优化文本编辑器显示">优化文本编辑器显示</h2>
<p>让界面交互更直观。</p>
<h3 id="显示行号显示空白字符">显示行号，显示空白字符</h3>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; editor -&gt; text editors -&gt; show line numbers show whitespace characters ，然后点击configure visibility 设置如下图。</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmqqvhck3j30lp0kb784.jpg" alt="显示行号和空白字符" loading="lazy"></figure>
<h3 id="调整编辑器字体和大小">调整编辑器字体和大小</h3>
<ul>
<li>window -&gt; preferences -&gt; General -&gt; appearance -&gt; colors and fonts，在点开 Basic 、 Java 等下，找到 Text Font 字样，在选择 Edit 进行调整。</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmr22b3wsj30lp0kbn0a.jpg" alt="设置字体" loading="lazy"></figure>
<h3 id="设置java默认风格每行最大字符数量">设置java默认风格每行最大字符数量</h3>
<p>在使用ctrl + shift + f格式化java代码时，经常会遇到换行的问题，默认风格一行最大为80个字符，</p>
<ul>
<li>window -&gt; preferences -&gt; java -&gt; code style -&gt; formatter -&gt; edit... -&gt; line wrapping -&gt; maximum line width 可以根据需要修改.</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/smartBBer/picBox/master/img/006KCUaNgy1fwmrepii6tj30lp0kb0wk.jpg" alt="最大行显示数" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java indexOf()实现]]></title>
        <id>https://tooyi.github.io/post/java-indexof/</id>
        <link href="https://tooyi.github.io/post/java-indexof/">
        </link>
        <updated>2018-10-25T00:50:43.000Z</updated>
        <summary type="html"><![CDATA[<p>代码记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>代码记录</p>
<!-- more -->
<h3 id="indexof源码解析">indexOf源码解析</h3>
<pre><code class="language-java">public int indexOf(String str) {
    return indexOf(str, 0);
}
 
public int indexOf(String str, int fromIndex) {
    return indexOf(value, 0, value.length,str.value, 0, str.value.length, fromIndex);
}

static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) {
    //1、当开始查找位置 大于等于 源字符串长度时,如果[查找字符串]为空,则:
    //返回字符串的长度,否则返回-1.
    if (fromIndex &gt;= sourceCount) { 
        return (targetCount == 0 ? sourceCount : -1);
    }
    //2、如果fromIndex 小于 0,则从 0开始查找。
    if (fromIndex &lt; 0) { 
        fromIndex = 0;
    }
    //3、如果[查找字符串]为空,则返回fromIndex
    if (targetCount == 0) { 
        return fromIndex;
    }
    //4、开始查找,从[查找字符串]中得到第一个字符,标记为first
    char first = target[targetOffset];
    //4.1、计算[源字符串最大长度]
    int max = sourceOffset + (sourceCount - targetCount);
    //4.2、遍历查找
    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { 
        //4.2.1、从[源字符串]中,查找到第一个匹配到[目标字符串]first的位置 
        //for循环中,增加while循环 
        /* Look for first character. */ 
        if (source[i] != first) { 
            while (++i &lt;= max &amp;&amp; source[i] != first); 
        } 
        //4.2.2、如果在[源字符串]中,找到首个[目标字符串], 
        //则匹配是否等于[目标字符串] 
        /* Found first character, now look at the rest of v2 */ 
        if (i &lt;= max) { 
            //4.2.2.1、得到下一个要匹配的位置,标记为j 
            int j = i + 1; 
            //4.2.2.2、得到其余[目标字符串]的长度,标记为end 
            int end = j + targetCount - 1; 
            //4.2.2.3、遍历,其余[目标字符串],从k开始, 
            //如果j不越界(小于end,表示:其余[目标字符串]的范围), 
            //同时[源字符串]==[目标字符串],则 //自增,继续查找匹配。j++、k++ 
            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); 
            //4.2.2.4、如果j与end相等,则表示: 
            //源字符串中匹配到目标字符串,匹配结束,返回i。 
            if (j == end) { 
                /* Found whole string. */ 
                return i - sourceOffset; 
            } 
        }
    }
    //其余情况,返回-1.return -1; 
    return -1;
} 
</code></pre>
<h3 id="实现">实现</h3>
<blockquote>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
</blockquote>
<pre><code class="language-java">public int strStr(String haystack, String needle) {
        if(needle.length() == 0) { //当noodle为空应该返回0
            return 0;
        } else if(needle.length() &gt; haystack.length()) { //当needle长度大于haystack，返回-1
            return -1;
        } else {
            char first = needle.charAt(0);
            int max = haystack.length() - needle.length();
            for(int i = 0; i &lt;= max; i++) {
                if(haystack.charAt(i) != first) {
                    while(++i &lt;= max &amp;&amp; haystack.charAt(i) != first);
                }
                if(i &lt;= max) {
                    int j = i + 1;
                    int end = j + needle.length() - 1;
                    for(int k = 1; j &lt; end &amp;&amp; haystack.charAt(j) == needle.charAt(k); j++, k++);
                    if(j == end) {
                        return i;
                    }
                }
            }
            return -1;
        }
    }
    public int strStr2(String haystack, String needle) {
        if(needle.equals(&quot;&quot;)||haystack.equals(needle)){
            return 0;
        }
        int index=-1;
        if(haystack.contains(needle)){
            String[] str=haystack.split(needle); 
            if(str.length&gt;=1){
                index=str[0].length();
            }else {
                index=0;
            }
        }else{
                index=-1;
            }
        return index;
    }
</code></pre>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java框架总结]]></title>
        <id>https://tooyi.github.io/post/java-zong-jie/</id>
        <link href="https://tooyi.github.io/post/java-zong-jie/">
        </link>
        <updated>2018-10-12T00:42:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java框架总结">Java框架总结</h2>
<p>使用SpringMVC + Spring + Mybatis （SSM）框架</p>
<p>使用Struts2 + Spring + Hibernate （SSH）框架</p>
<p>相当于 页面 -&gt; Servlet -&gt; Java（接口类） -&gt; JDBC -&gt; 数据库</p>
<p>SpringPost</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/tooyi/picBox/master/img/006KCUaNgy1fwaf90g4snj311h0kvwhn.jpg" alt="图示" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2018/10/16/5bc5f2cb2ac77.jpg" alt="SSM SSH框架总结.jpg" loading="lazy"></figure>
<h3 id="欢迎关注我的微信公众号">欢迎关注我的微信公众号</h3>
<figure data-type="image" tabindex="3"><img src="http://upload-images.jianshu.io/upload_images/3990834-c91d28f8be4121e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：柏战不殆" loading="lazy"></figure>
]]></content>
    </entry>
</feed>