{"posts":[{"title":"换一个新主题 - Gridea Themes Vant","content":"访问旧博客 新博客使用Gridea管理，旧博客文章暂时未全部搬运。若访问旧博客，请访问涂诣的官方网站 👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://tooyi.github.io/post/hello-gridea/"},{"title":"数据库-函数依赖及范式","content":"通俗讲解 数据库-函数依赖及范式（通俗易懂） 一、基础概念 要理解范式，首先必须对知道什么是关系数据库，如果你不知道，我可以简单的不能再简单的说一下：关系数据库就是用二维表来保存数据。表和表之间可以……（省略10W字）。 然后你应该理解以下概念： **实体：**现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，不如说“老师与学校的关系”。 **属性：**教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，属性可以看作是“表的一列”。 **元组：**表中的一行就是一个元组。 **分量：**元组的某个属性值。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“不可分的”。否则就不是关系数据库了。 **码：**表中可以唯一确定一个元组的某个属性（或者属性组），如果这样的码有不止一个，那么大家都叫候选码，我们从候选码中挑一个出来做老大，它就叫主码。 **全码：**如果一个码包含了所有的属性，这个码就是全码。 **主属性：**一个属性只要在任何一个候选码中出现过，这个属性就是主属性。 **非主属性：**与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。 **外码：**一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。 二、6个范式 好了，上面已经介绍了我们掌握范式所需要的全部基础概念，下面我们就来讲范式。首先要明白，范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式… 第一范式（1NF） 属性不可分。 在前面我们已经介绍了属性值的概念，我们说，它是“不可分的”。而第一范式要求属性也不可分。那么它和属性值不可分有什么区别呢？给一个例子： name tel age 大宝 13612345678 22 小明 13988776655 010－1234567 21 Ps：这个表中，属性值“分”了。 name tel age 手机 座机 大宝 13612345678 021－9876543 22 小明 13988776655 010－1234567 21 Ps：这个表中，属性 “分”了。 这两种情况都不满足第一范式。不满足第一范式的数据库，不是关系数据库！所以，我们在任何关系数据库管理系统中，做不出这样的“表”来。（也就是说，只要是关系数据库就是第一范式） 第二范式（2NF） 符合1NF，并且，非主属性完全依赖于码，消除部分依赖。 听起来好像很神秘，其实真的没什么。 一个候选码中的主属性也可能是好几个。如果一个主属性，它不能单独做为一个候选码，那么它也不能确定任何一个非主属性。给一个反例：我们考虑一个小学的教务 管理系统，学生上课指定一个老师，一本教材，一个教室，一个时间，大家都上课去吧，没有问题。那么数据库怎么设计？（学生上课表） 学生 课程 老师 老师职称 教材 教室 上课时间 小明 一年级语文（上） 大宝 副教授 《小学语文1》 101 14：30 一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－&gt;教室 一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－&gt;老师 一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－&gt;老师职称 一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－&gt;教材 一个学生上一门课，一定在特定时间。所以有（学生，课程）－&gt;上课时间 因此（学生，课程）是一个码。 然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－&gt;教材。（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。出现这样的情况，就不满足第二范式！ 有什么不好吗？你可以想想： 1、校长要新增加一门课程叫“微积分”，教材是《大学数学》，怎么办？学生还没选课，而学生又是主属性，主属性不能空，课程怎么记录呢，教材记到哪呢? ……郁闷了吧?(插入异常) 2、下学期没学生学一年级语文（上）了，学一年级语文（下）去了，那么表中将不存在一年级语文（上），也就没了《小学语文1》。这时候，校长问：一年级语文（上）用的什么教材啊？……郁闷了吧?(删除异常) 3、校长说：一年级语文（上）换教材，换成《大学语文》。有10000个学生选了这么课，改动好大啊！改累死了……郁闷了吧？（修改异常） 那应该怎么解决呢？投影分解，将一个表分解成两个或若干个表 学生 课程 老师 老师职称 教室 上课时间 小明 一年级语文（上） 大宝 副教授 101 14：30 学生上课表新 课程 教材 一年级语文（上） 《小学语文1》 课程的表 第三范式（3NF） 符合2NF，并且，消除传递依赖 上面的“学生上课表新”符合2NF，可以这样验证：两个主属性单独使用，不用确定其它四个非主属性的任何一个。但是它有传递依赖！ 在哪呢？问题就出在“老师”和“老师职称”这里。一个老师一定能确定一个老师职称。有什么问题吗？想想： 1、老师升级了，变教授了，要改数据库，表中有N条，改了N次……（修改异常） 2、没人选这个老师的课了，老师的职称也没了记录……（删除异常） 3、新来一个老师，还没分配教什么课，他的职称记到哪？……（插入异常） 那应该怎么解决呢？和上面一样，投影分解： 学生 课程 老师 教室 上课时间 小明 一年级语文（上） 大宝 101 14：30 老师 老师职称 大宝 副教授 BC范式（BCNF） 符合3NF，并且，主属性不依赖于主属性 若关系模式属于第三范式，且每个属性都不传递依赖于键码，则属于BC范式。 ​ 若某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。 那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？ ​ 已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量 ​ 码：（管理员，物品名），（仓库名，物品名） ​ 主属性：仓库名、管理员、物品名非主属性：数量 ​ ∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。 ​ ∴ 此关系模式属于3NF。 ​ 好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作： ​ 1.先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。 ​ 2.如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。 ​ 从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。 ​ 造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。 ​ 解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。 ​ 1.仓库表（仓库名，管理员） ​ 2.库存表（仓库名，物品名，数量） ​ 这样，之前的插入异常，修改异常与删除异常的问题就被解决了。 通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。 一般，一个数据库设计符合3NF或BCNF就可以了。在BC范式以上还有第四范式、第五范式。 第四范式 ​ 要求把同一表内的多对多关系删除。 第五范式 ​ 从最终结构重新建立原始结构。 ","link":"https://tooyi.github.io/post/shu-ju-ku-han-shu-yi-lai-ji-fan-shi/"},{"title":"微信小程序 WXHL 中截取字符串","content":"代码记录 1.首先 在对应页面下新建 “ center.wxs ” 文件 这个文件是小程序自身 一套脚本语言 2.在 .wxs 文件中 写 截取字符串的 方法 // 小程序页面中 如何截取字符串 var substr = function(val) { if (val.length == 0 || val == undefined) { return false; } else if (val.length &gt; 12) { return val.substring(0,12) + &quot;...&quot;; }else{ return val; } } //暴露substr方法 module.exports.substr =substr 3.在center.wxml页面中 引入 然后在 “ {{}} ” 中 使用 ，如下 &lt;view class='p'&gt;{{intercept.substr(item.evaluation.name)}}&lt;/view&gt; ","link":"https://tooyi.github.io/post/wei-xin-wxhl/"},{"title":"MySQL读写分离","content":"Java高级面试必问系列 为什么要读写分离？ Mysql主从复制 MySQL主从延迟导致的生产环境的问题 进入正题，开始撞壁！ 1、面试题 你们有没有做MySQL读写分离？ 如何实现mysql的读写分离？MySQL主从分离原理的是啥？如何解决mysql主从同步的延时问题？ 2、面试官心里分析 这个，高并发这个阶段，那肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？ 3、面试题剖析 （1）如何实现mysql的读写分离？ 其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。 （2）MySQL主从复制原理的是啥？ 主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。 这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。 所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。 而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。 所以mysql实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。 这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。 所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。 主从复制的原理 主从延迟问题产生的原因 主从复制的数据丢失问题，以及半同步复制的原理 并行复制的原理，多库并发重放relay日志，缓解主从延迟问题 （3）mysql主从同步延时问题（精华） 线上确实处理过因为主从同步延时问题，导致的线上的bug，小型的生产事故 show status，Seconds_Behind_Master，你可以看到从库复制主库的数据落后了几ms 其实这块东西我们经常会碰到，就比如说用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。 所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步 所以这个时候，我们可以考虑的一个事情就是，你可以用mysql的并行复制，但是问题是那是库级别的并行，所以有时候作用不是很大 所以这个时候。。 通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。 一般来说，如果主从延迟较为严重： 分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计 打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。 重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了 ","link":"https://tooyi.github.io/post/mysql-du-xie-fen-chi/"},{"title":"PHP 爬虫","content":"学习参考小结 简单获取百度title &lt;?PHP // 通过 file_get_contents 函数获取百度页面源码 $html = file_get_contents(&quot;https://www.baidu.com/index.html&quot;); // 通过 preg_replace 函数使页面源码由多行变单行 $htmlOneLine = preg_replace(&quot;/\\r|\\n|\\t/&quot;,&quot;&quot;,$html); // 通过 preg_match 函数提取获取页面的标题信息 preg_match(&quot;/&lt;title&gt;(.*)&lt;\\/title&gt;/iU&quot;,$htmlOneLine,$titleArr); // 由于 preg_match 函数的结果是数组的形式 $title = $titleArr[1]; // 通过 echo 函数输出标题信息 echo $title; ?&gt; 乱码解决 &lt;?PHP // 乱码解决办法，把其他编码格式通过 mb_convert_encoding 函数统一转为 UTF-8 格式 $html = mb_convert_encoding($html,'UTF-8','UTF-8,GBK,GB2312,BIG5'); // 还有一种因为gzip所以出现乱码的，我会在以后讲 ?&gt; 获取不到标题信息 &lt;?PHP // 获取不到标题信息解决办法，首先判断是否能获取到页面源码 // 如果能获取到但还是不能获取到标题信息 // 我猜测的问题是：因为是使用正则表达式获取的，源码没有变成一行，获取起来就会出现问题 $htmlOneLine=preg_replace(&quot;/\\r|\\n|\\t/&quot;,&quot;&quot;,$html); ?&gt; 获取不到页面源码 &lt;?PHP // 像新浪微博你可能获取到的是“Sina Visitor System” // 解决办法添加header信息 $opts = array( 'http'=&gt;array( 'method'=&gt;&quot;GET&quot;, &quot;timeout&quot;=&gt;20, 'header'=&gt;&quot;User-Agent: Spider \\r\\n&quot;, ) ); $context = stream_context_create($opts); $html = file_get_contents($domain,0,$context,0,150000); // 这样就能获取到新浪微博的页面了 ?&gt; 爬取图片 &lt;?php header(&quot;Content-type:text/html;Charset=utf-8&quot;); $ch = curl_init(); $url = &quot;https://pixabay.com/&quot;; curl_setopt($ch, CURLOPT_USERAGENT, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.113 Safari/537.36&quot;); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $content = curl_exec($ch); $string = file_get_contents($url); preg_match_all(&quot;/&lt;img([^&gt;]*)\\s*src=('|\\&quot;)([^'\\&quot;]+)('|\\&quot;)/&quot;, $string, $matches); $new_arr = array_unique($matches[3]); foreach ($new_arr as $key) { echo &quot;&lt;img src=$key&gt;&quot;; } ","link":"https://tooyi.github.io/post/php-pa-chong/"},{"title":"在线学习SQL","content":"推荐几个在线学习SQL的网页 SQL Fiddle 地址：http://sqlfiddle.com/ 提供有MySQL5.6、Oracle11g R2、PostgreSQL9.6及9.3、SQLite（WedSQL）、SQLite（SQL.js)、MS SQL Server 2017. 总体体验不错。 SQLZOO 地址：http://zh.sqlzoo.net/wiki/SELECT_basics/zh SQL练习网站 做了下前两篇，附上答案。 SQLZOO 前两节 SELECT basics 和 SELECT name 的答案。 SELECT basic 1.修改此例子,以顯示德國 Germany 的人口。 SELECT population FROM world WHERE name = 'Germany' 2.修改此例子,查詢面積為 5,000,000 以上平方公里的國家,對每個國家顯示她的名字和人均國內生產總值(gdp/population)。 SELECT name, gdp/population FROM world WHERE area &gt; 5000000 3.顯示“Ireland 愛爾蘭”,“Iceland 冰島”,“Denmark 丹麥”的國家名稱和人口。 SELECT name, population FROM world WHERE name IN ('Ireland', 'Iceland', 'Denmark'); 4.修改此例子,以顯示面積為 200,000 及 250,000 之間的國家名稱和該國面積。 SELECT name, area FROM world WHERE area BETWEEN 200000 AND 250000 SELECT names 1.找出以 Y 為開首的國家。 SELECT name FROM world WHERE name LIKE 'Y%' 2.找出以 Y 為結尾的國家。 SELECT name FROM world WHERE name LIKE '%Y' 3.找出所有國家,其名字包括字母x。 SELECT name FROM world WHERE name LIKE '%x%' 4.找出所有國家,其名字以 land 作結尾。 SELECT name FROM world WHERE name LIKE '%land' 5.找出所有國家,其名字以 C 作開始,ia 作結尾。 SELECT name FROM world WHERE name LIKE 'C%ia' 6.找出所有國家,其名字包括字母oo。 SELECT name FROM world WHERE name LIKE '%oo%' 7.找出所有國家,其名字包括三個或以上的a。 SELECT name FROM world WHERE name LIKE '%a%a%a%' 8.找出所有國家,其名字以t作第二個字母。 SELECT name FROM world WHERE name LIKE '_t%' ORDER BY name 9.找出所有國家,其名字都有兩個字母 o,被另外兩個字母相隔着。 SELECT name FROM world WHERE name LIKE '%o__o%' ORDER BY name 10.找出所有國家,其名字都是 4 個字母的。 SELECT name FROM world WHERE name LIKE '____' 11.顯示所有國家名字,其首都和國家名字是相同的 SELECT name FROM world WHERE name = capital 12.顯示所有國家名字,其首都是國家名字加上” City”。 SELECT name FROM world WHERE capital = concat(name, ' City') 13.找出所有首都和其國家名字,而首都要有國家名字中出現。 SELECT capital, name FROM world WHERE capital LIKE concat('%',name,'%') 14.找出所有首都和其國家名字,而首都是國家名字的延伸。 你應顯示 Mexico City,因它比其國家名字 Mexico 長。 你不應顯示 Luxembourg,因它的首都和國家名相是相同的。 SELECT name, capital FROM world WHERE capital LIKE concat('%',name,'_%') 15.&quot;Monaco-Ville&quot;是合併國家名字 &quot;Monaco&quot; 和延伸詞&quot;-Ville&quot;. 顯示國家名字，及其延伸詞，如首都是國家名字的延伸。 SELECT name, REPLACE(capital, name, '') FROM world WHERE capital LIKE CONCAT('%',name,'%') AND REPLACE(capital, name, '') &lt;&gt; '' ","link":"https://tooyi.github.io/post/zai-xian-xue-xi-sql/"},{"title":"Oracle学习小结","content":"最近学习Oracle，做个小总结 Oracle 预备知识 1.Oracle数据库中查询操作的基本语法 SELECT [ALL|DISTINCT]column_name[,expression…] FROM table1_name[,table2_name,view_name,…] [WHERE condition] [GROUP BY column_name1[,column_name2,…] [HAVING group_condition]] [ORDER BY column_name2 [ASC|DESC][,column_name2,…]]; 2.常用的统计（聚集）函数 函 数 格 式 功 能 COUNT COUNT([DISTINCT|ALL] *) 返回结果集中记录个数 COUNT COUNT([DISTINCT|ALL] column) 返回结果集中非空记录个数 AVG AVG([DISTINCT|ALL] column) 返回列或表达式的平均值 MAX MAX([DISTINCT|ALL] column ) 返回列或表达式的最大值 MIN MIN([DISTINCT|ALL] column ) 返回列或表达式的最小值 SUM SUM([DISTINCT|ALL] column ) 返回列或表达式的总和 STDDEV STDDEV(column) 返回列或表达式的标准差 VARIANCE VARIANCE(column) 返回列或表达式的方差 除了COUNT(*)函数外，其他的统计函数都不考虑返回值或表达式为NULL的情况。 聚集函数只能出现在目标列表达式、ORDER BY子句、HAVING子句中，不能出现在WHERE子句和GROUP BY子句中。 默认对所有的返回行进行统计，包括重复的行；如果要统计不重复的行信息，则可以使用DISTINCT选项。 如果对查询结果进行了分组，则聚集函数的作用范围为各个组，否则聚集函数作用于整个查询结果。 创建表和数据 CREATE TABLE customers( customer_id NUMBER(2) PRIMARY KEY, name CHAR(10) NOT NULL, phone VARCHAR(15) NOT NULL, email VARCHAR(15), address VARCHAR(30), code VARCHAR(10) ); CREATE TABLE publishers( publisher_id NUMBER(2) PRIMARY KEY, name VARCHAR(32), contact CHAR(10), phone VARCHAR(15) ); CREATE TABLE books( isbn VARCHAR(15) PRIMARY KEY, title VARCHAR(15), pubdate DATE, publisher_id NUMBER(2) REFERENCES publishers(publisher_id), cost NUMBER(4,2), retail NUMBER(4,2), category VARCHAR(15) ); CREATE TABLE authors( author_id NUMBER(2) PRIMARY KEY, name VARCHAR(15)); CREATE TABLE bookauthor( isbn VARCHAR(15) REFERENCES books(isbn), author_id NUMBER(2) REFERENCES authors(author_id), primary key(isbn,author_id) ); CREATE TABLE orders( order_id NUMBER(2) PRIMARY KEY, customer_id NUMBER(2) REFERENCES customers(customer_id), orderdate DATE NOT NULL, shipdate DATE NOT NULL, shipaddress VARCHAR(30), shipcode VARCHAR(10) ); CREATE TABLE orderitem( ttem_id NUMBER(2) PRIMARY KEY, order_id NUMBER(2) REFERENCES orders(order_id), isbn VARCHAR(15) REFERENCES books(isbn), quantity NUMBER(2) ); 瞎写的数据 INSERT INTO customers VALUES(1,'小李','13300000000','1222@qq.com','东莞','122121'); INSERT INTO customers VALUES(2,'小刘','13300000000','1222@qq.com','上海浦东','122121'); INSERT INTO customers VALUES(3,'小王','13300000000','1222@qq.com','北京大学','122121'); INSERT INTO customers VALUES(4,'小张','13300000000','1222@qq.com','清华大学','122121'); insert into customers values(5,'小宋','123456','2222@qq.com','湖南大学','421000' ); insert into customers values(6,'小岳','234567','1111@qq.com','北京中关村','421000' ); insert into publishers values(1,'东四出版社','给予','345678'); insert into publishers values(2,'清华大学出版社','清华','345678'); insert into publishers values(3,'电子工业出版社','电工','345678'); insert into books values('0001','数据结构',sysdate,1,25.25,30.00,'计算机类'); insert into books values('0002','算法设计',to_date('2009-01-01','yyyy-mm-dd'),1,34.24,42.00,'计算机类'); insert into books values('0003','python',to_date('1996-12-03','yyyy-mm-dd') ,1,34.24,41.00,'计算机类'); insert into books values('0004','数据库大全',to_date('1990-12-03','yyyy-mm-dd') ,2,34.24,90.00,'计算机类'); insert into books values('0005','Oracle解读',to_date('2007-02-03','yyyy-mm-dd') ,3,34.40,90.00,'计算机类'); insert into books values('0006','java',to_date('2007-02-03','yyyy-mm-dd') ,1,34.40,90.00,'计算机类'); insert into books values('0007','大海',sysdate,1,25.25,30.00,'文学类'); insert into books values('0008','非我',sysdate,1,25.25,30.00,'哲学类'); insert into authors values(1,'廖雪峰'); insert into authors values(2,'唐三'); insert into bookauthor values('0001',1); insert into bookauthor values('0002',2); insert into orders values(1,1,sysdate,sysdate,'新华书店','421000'); insert into orders values(2,2,to_date ( '2007-11-20 18:31:34' , 'YYYY-MM-DD HH24:MI:SS' ),to_date ( '2007-12-30 18:31:34' , 'YYYY-MM-DD HH24:MI:SS' ),'新华书店','421000'); insert into orders values(3,3,sysdate,sysdate,'电子工业出版社','421000'); insert into orders values(4,4,to_date ( '2007-12-20 18:31:34' , 'YYYY-MM-DD HH24:MI:SS' ),to_date ( '2007-12-21 18:31:34' , 'YYYY-MM-DD HH24:MI:SS' ),'清华大学出版社','421000'); insert into orderitem values(1,1,'0001',20); insert into orderitem values(2,2,'0002',20); 查询 以下查询基于图书销售系统表 （1） 查询当前所有客户信息。 select * from customers; （2） 查询图书ISBN、书名、批发价以及零售价信息。 select isbn,title,cost,retail from books; （3） 查询所有图书的种类。 select DISTINCT category from books; （4） 查询图书ISBN、图书名及作者名信息。 select books.isbn,books.title,authors.name from books inner join bookauthor on books.isbn=bookauthor.isbn join authors on authors.author_id=bookauthor.author_id; （5） 查询所有订单信息。 select * from orders; （6） 查询所有出版社信息。 select * from publishers; （7） 查询所有订单明细信息。 select * from orderitem; （8） 查询出版日期在2009年1月1日之后的图书信息。 select * from books where pubdate &gt; to_date('2009-01-01','yyyy-mm-dd'); （9） 查询所有图书ISBN、图书名、出版日期，并按出版日期降序排序。 select isbn,title,pubdate from books order by pubdate desc; （10） 查询所有图书ISBN、图书名、出版社、出版日期，按批发价格排序，对于批发价相同的，再按零售价排序。 select * from books inner join publishers on books.publisher_id=publishers.publisher_id order by cost,retail; （11） 查询图书名以“数据库”开头的图书信息。 select * from books where title like '数据库%'; （12） 查询所有书名中包含“Oracle”的图书信息。 select * from books where title like '%Oracle%'; （13） 查询出版日期在2007年1月至2009年1月的所有图书。 select * from books where pubdate &gt;= to_date('2007-01-01','yyyy-mm-dd') and pubdate &lt;= to_date('2009-1-31','yyyy-mm-dd'); （14） 查询“电子工业出版社”和“清华大学出版社”出版的图书。 select * from books join publishers on books.publisher_id=publishers.publisher_id and (publishers.name like '清华大学出版社' or publishers.name like '电子工业出版社'); （15） 查询所有订单信息，按订单日期排序。对于订单日期相同的，再按发货日期排序。 select * from orders order by orderdate,shipdate; （16） 查询所有发货日期比订货日期晚７天的订单信息。 select * from orders where (to_number(shipdate-orderdate))&gt;=7; （17） 统计各类图书的数量，平均零售价格、平均批发价格。 select category,count(*),avg(retail),avg(cost) from books GROUP BY category; （18） 统计各个出版社出版图书的数量、最高批发价格、最高零售价格、最低批发价格和最低零售价格。 select name,count(*),max(cost),max(retail),min(cost),min(retail) from books join publishers on books.publisher_id =publishers.publisher_id GROUP BY name; （19） 统计每个客户的订单数量。 select name,count(*) from orders join customers on orders.customer_id=customers.customer_id group by name; （20） 统计每个作者编写的图书数量。 select name,count(*) from bookauthor join authors on authors.author_id=bookauthor.author_id group by name; ","link":"https://tooyi.github.io/post/oracle-xue-xi-xiao-jie/"},{"title":"Nginx 命令","content":"Windows下Nginx的启动、停止等命令 Windows下Nginx的启动、停止等命令 在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。 1、启动： C:\\server\\nginx-1.0.2&gt;start nginx或 C:\\server\\nginx-1.0.2&gt;nginx.exe 2、停止： C:\\server\\nginx-1.0.2&gt;nginx.exe -s stop或 C:\\server\\nginx-1.0.2&gt;nginx.exe -s quit 注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。 3、配置文件修改重新载入Nginx： C:\\server\\nginx-1.0.2&gt;nginx.exe -s reload 当配置信息修改，需要重新载入这些配置时使用此命令。 4、重新打开日志文件： C:\\server\\nginx-1.0.2&gt;nginx.exe -s reopen 5、查看Nginx版本： C:\\server\\nginx-1.0.2&gt;nginx -v 6、验证配置是否正确: C:\\server\\nginx-1.0.2&gt;nginx -t 7.查看是否启动成功： C:\\server\\nginx-1.0.2&gt;tasklist /fi &quot;imagename eq nginx.exe&quot; ","link":"https://tooyi.github.io/post/nginx/"},{"title":"WNMP 配置","content":"win10 + nginx + php7 + mysql 1.首先需要的应用程序包。 PHP: VC15 x64 Non Thread Safe (2019-Feb-06 02:14:41)（nginx 下 php 是以 FastCGI 的方式运行，所以我们下载非线程安全也就是nts的php包） Nginx: nginx/Windows-1.14.2 （下载 stable version） MySql：mysql-8.0.15-winx64.zip MySql8.xx 的可以参考这个贴 MySQL 8.0.15安装教程(windows 64位) 附一个用了比较久的 MySql 界面管理器 免费的 Navicat Premium 非商业版许可证：学术伙伴计划 - 学生 有一个教育邮箱就可以申请 2.安装与配置。 1）php安装与配置。 将下载好的 php 包文件解压到某一个目录下，例如我的是：D:\\wnmp。把解压后的文件目录改为 php7，将里面的 php.ini-production 文件复制一份并改名为 php.ini，用文本编辑器将它打开。 ;将里面的 ; On windows: extension_dir = &quot;./txt&quot; ;改为 ; On windows: extension_dir = &quot;D:/wnmp/php7/ext&quot; 将下面两个扩展前面的“;”去掉。（因为 php7 不支持 mysql 扩展了，所以这里只有 mysqli 和 pdo 扩展) ;extension=mysqli ;extension=pdo_mysql ;extension=openssl 最后让PHP支持 nginx，将下面一行前面的“;”去掉。 ;cgi.fix_pathinfo=1 2）nginx 安装与配置。 先在 D:/wnmp 目录下新建一个 www 文件夹，作为服务器的根目录。 将下载好的 nginx 包文件解压到D:\\wnmp目录下，重命名为 nginx。打开 nginx\\conf 下的 nginx.conf 文件来配置 nginx。 #将一下代码 location/ { root html; index index.html index.htm; } #改为 location/ { root D:/wnmp/www; #将站点的根目录定位到 D:/wnmp/www index index.html index.htm; } #再将一下代码 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} #改为 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ { root D:/wnmp/www; fastcgi_pass localhost:9000; fastcgi_index index.php; # 这里$document_root指的是上面定义好的nginx根目录：D:/wnmp/www fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } #保存好配置即可。 3.启动。 手动启动 php 和 nginx 来跑一下。 1）命令行php目录下键入 php-cgi.exe -b 127.0.0.1:9000 -c D:/wnmp/php7/php.ini（输入以后没有反应，但是不能关掉命令行） 2）命令行nginx目录下 start nginx 3）在www目录下新建一个 phpinfo.php 文件 &lt;?php phpinfo(); ?&gt; 4）浏览器中输入 localhost/phpinfo.php 或者 127.0.0.1/phpinfo.php，出现下面内容则说明php在nginx中运行成功了。 本文参考 http://www.cnblogs.com/huayangmeng/archive/2011/06/15/2081337.html ","link":"https://tooyi.github.io/post/wnmp/"},{"title":"composer 脱坑记","content":"解决composer update太慢 composer 介绍 Composer 是 PHP5.3以上 的一个依赖管理工具。它允许你声明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 &quot;packages&quot; 和 &quot;libraries&quot;，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。 那么，问题来了 composer update 太慢，怎么解决 卡在这里怎么办 Loading composer repositories with package information Updating dependencies (including require-dev) 后来看到这里： https://pkg.phpcomposer.com/#how-to-install-composer 方法一 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户）并执行如下命令 composer config -g repo.packagist composer https://packagist.phpcomposer.com 方法二： 修改当前项目的 composer.json 配置文件： 打开命令行窗口（windows用户）或控制台（Linux、Mac 用户），进入你的项目的根目录（也就是 composer.json 文件所在目录），执行如下命令： composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息（你也可以自己手工添加）： &quot;repositories&quot;: { &quot;packagist&quot;: { &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; } } 如果方法一不管用，尝试下方法二。 ","link":"https://tooyi.github.io/post/composer-tuo-keng-ji/"},{"title":"懒加载与预加载","content":"什么是懒加载、预加载？ 懒加载 1.什么是懒加载？ 懒加载也就是延迟加载。 当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。 2.为什么要使用懒加载？ 很多页面，内容很丰富，页面很长，图片较多。比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。要是页面载入就一次性加载完毕。估计大家都会等到黄花变成黄花菜了。 3.懒加载的原理是什么？ 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置； 4.懒加载的实现步骤？ 1)首先，不要将图片地址放到src属性中，而是放到其它属性(data-original)中。 2)页面加载完成后，根据scrollTop判断图片是否在用户的视野内，如果在，则将data-original属性中的值取出存放到src属性中。 3)在滚动事件中重复判断图片是否进入视野，如果进入，则将data-original属性中的值取出存放到src属性中。 5.懒加载的优点是什么？ 页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好 //懒加载代码实现 var viewHeight = document.documentElement.clientHeight // 可视区域的高度 function lazyload () { // 获取所有要进行懒加载的图片 var eles = document.querySelectorAll('img[data-original][lazyload]') Array.prototype.forEach.call(eles, function (item, index) { var rect if (item.dataset.original === '') return rect = item.getBoundingClientRect() // 图片一进入可视区，动态加载 if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) { !function () { var img = new Image() img.src = item.dataset.original img.onload = function () { item.src = img.src } item.removeAttribute('data-original') item.removeAttribute('lazyload') }() } }) } // 首屏要人为的调用，否则刚进入页面不显示图片 lazyload() document.addEventListener('scroll', lazyload) 预加载 预加载的核心要点如下： 1.图片等静态资源在使用之前的提前请求； 2.资源后续使用时可以从缓存中加载，提升用户体验； 3.页面展示的依赖关系维护（必需的资源加载完才可以展示页面，防止白屏等）； 实现预加载主要有三个方法： 1.html中img标签最初设置为display:none； 2.js脚本中使用image对象动态创建好图片； 3.使用XMLHttpRequest对象可以更加精细的控制预加载过程，缺点是无法跨域： 1.什么是预加载？ 提前加载图片，当用户需要查看时可直接从本地缓存中渲染 2.为什么要使用预加载？ 图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。 3.实现预加载的方法有哪些？ 方法一：用CSS和JavaScript实现预加载 方法二：仅使用JavaScript实现预加载 方法三：使用Ajax实现预加载 详见：Javascript图片预加载详解 3、懒加载和预加载的对比 1)概念： 懒加载也叫延迟加载：JS图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 2)区别： 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 3)懒加载的意义及实现方式有： 意义： 懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 实现方式： 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 4)预加载的意义及实现方式有： 意义: 预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。 实现方式： 实现预载的方法非常多，比如：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。 常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。 4、补充知识 屏幕可视窗口大小 原生方法： window.innerHeight 标准浏览器及IE9+ || document.documentElement.clientHeight 标准浏览器及低版本IE标准模式 || document.body.clientHeight 低版本混杂模式 jQuery方法： $(window).height(); 浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离： 原生方法： window.pagYoffset 标准浏览器及IE9+ || document.documentElement.scrollTop 兼容ie低版本的标准模式 || document.body.scrollTop 兼容混杂模式； jQuery方法： $(document).scrollTop(); 获取元素的尺寸 $(o).width() = o.style.width; $(o).innerWidth() = o.style.width+o.style.padding; $(o).outerWidth() = o.offsetWidth = o.style.width+o.style.padding+o.style.border； $(o).outerWidth(true) = o.style.width+o.style.padding+o.style.border+o.style.margin； 注意 要使用原生的style.xxx方法获取属性，这个元素必须已经有内嵌的样式，如果原先是通过外部或内部样式表定义css样式，必须使用o.currentStyle[xxx] || document.defaultView.getComputedStyle(0)[xxx]来获取样式值。 获取元素的位置信息 jQuery： $(o).offset().top&lt;/code&gt;元素距离文档顶的距离&lt;br&gt;&lt;code&gt;$(o).offset().left元素距离文档左边缘的距离。 原生：getoffsetTop(); 顺便提一下返回元素相对于第一个以定位的父元素的偏移距离，注意与上面偏移距的区别； jQuery：position()返回一个对象 $(o).position().left = o.style.left;&lt;/code&gt;&lt;br&gt;&lt;code&gt;$(o).position().top = o.style.top； 来源：懒加载和预加载 ","link":"https://tooyi.github.io/post/lan-jia-zai-yu-yu-jia-zai/"},{"title":"微信小程序---flex布局","content":"代码记录 微信小程序---flex布局 基础代码 &lt;!-- .wxml --&gt; &lt;view class='container'&gt; &lt;view class='chunk color1'&gt;1&lt;/view&gt; &lt;view class='chunk color2'&gt;2&lt;/view&gt; &lt;view class='chunk color3'&gt;3&lt;/view&gt; &lt;/view&gt; /* .wxss */ .chunk{ height: 100px; width: 100px; } .container { height: 400px; background: #898989; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } view 组件 使用 view 组件时，默认是列向排列 view 组件更改排列方向 display: inline; 使用 display: inline; 可以实现横向排列，但是不能设置高度和宽度，代码中虽然设置，但是无作用。 /* .wxss */ /* 增加 display: inline; */ .chunk{ height: 100px; width: 100px; display: inline; } .container { height: 400px; background: #898989; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } display: inline-block; inline-block 可以设置高度和宽度。 /* .wxss */ /* 增加 display: inline-block; */ .chunk{ height: 100px; width: 100px; display: inline-block; } .container { height: 400px; background: #898989; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } flex 而当使用 flex 布局时，默认是横向排列 /* .wxss */ /* 使用flex布局 */ .chunk{ height: 100px; width: 100px; } .container { height: 400px; display: flex; background: #898989; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } 更改排列方向 /* .wxss */ /* flex-direction: row; 实现行内排列， column实现列内排列*/ .chunk{ height: 100px; width: 100px; } .container { height: 400px; display: flex; background: #898989; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } 使用 flex 布局还有一个方便实现的功能 ————实现 view 组件的倒序排列 只需要加一个 flex-direction: row-reverse; /* .wxss */ /* flex-direction: row-reverse; 实现行内倒序排列 column-reverse;*/ .chunk{ height: 100px; width: 100px; } .container { height: 400px; display: flex; background: #898989; flex-direction: column-reverse; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } 这时候发现一个问题，现在是从底部开始排列的，想要在顶部开始排列，加上 justify-content: flex-end; /* .wxss */ /* justify-content: flex-end;*/ /* justify-content: space-between; 平均分布 center 剧中分布 space-around 等距分布 */ .chunk{ height: 100px; width: 100px; } .container { height: 400px; display: flex; background: #898989; flex-direction: column-reverse; justify-content: flex-end; } .color1{ background-color: red; } .color2{ background-color: blue; } .color3{ background-color: pink; } 这时仔细的你发现，flex-end 不是应该是从底部开始排列的？ 再仔细的你就会发现，前面加入了 flex-direction: column-reverse; 反转了一下，所以 flex-end 就变成 flex-start 的效果了。 ","link":"https://tooyi.github.io/post/wei-xin-xiao-cheng-xu-flex-bu-ju/"},{"title":"json格式化插件","content":"chrome浏览器-json格式化插件 第一步 下载json 的JSON-Handle插件：地址：http://jsonhandle.sinaapp.com/ 第二步 打开浏览器—&gt;右键点击三个点—&gt;更多工具—&gt;扩展程序—&gt;将crx插件拖入浏览器 这时候你运行你的程序 出现以下结果说明已经成功安装成功。 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/json-ge-shi-hua-cha-jian/"},{"title":"摩尔投票算法","content":"摩尔投票算法理解记录 摩尔投票算法 摩尔投票算法也可以叫做多数投票算法。 题 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 常规解法 遍历数组，并计数，找出出现次数大于 ⌊ n/2 ⌋ 的元素。 将数组排序，出现次数大于 ⌊ n/2 ⌋ 的元素必定在数组中间，返回nums[n/2]即可。 摩尔投票法求解 算法的时间和空间都很低，时间复杂度为O(n)，空间复杂度为O(1) 算法原理 每次从数组中找出一对不同的元素，将它们从数组中删除，直到遍历完整个数组。由于这道题已经说明一定存在一个出现次数超过一半的元素，所以遍历完数组后数组中一定会存在至少一个元素。 算法在局部变量中定义一个序列元素(m)和一个计数器(count)，初始化的情况下计数器为1； 算法依次扫描序列中的元素，当处理元素x的时候，如果序列元素(m)和x相等，计数器(count)自增1； 如果不等计数器(count)自减1，并判断计数器是否为0，如果为0，那么将x赋值给m，然后将计数器(count)设置为1(或将x的下一位元素赋值给m，计数器(count)设为0)； 处理之后，最后存储的序列元素(m)，就是这个序列中最多的元素。 （如果不确定是否存储的元素m是最多的元素，还可以进行第二遍扫描判断是否为最多的元素） 伪码实现 初始化元素m=nums[0],计数器count=1; for i = 1 : nums.length - 1 if m = nums[i] count++ else count-- if count = 0 m = numd[i + 1] count = 0 return m java实现 class Solution { public int majorityElement(int[] nums) { int count = 1, maj = nums[0]; for(int i = 1; i &lt; nums.length; i++) { if(maj == nums[i]) { count++; } else { count--; if(count == 0) { maj = nums[i + 1]; count = 0; } } } return maj; } } 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/mo-er-tou-piao-suan-fa/"},{"title":"Java 字符串常用类","content":"字符串知识总结 字符串查找 String 提供了两种查找字符串的方法，即 indexOf 与 lastIndexOf 方法。 1、indexOf（String s） 该方法用于返回参数字符串s在指定字符串中首次出现的索引位置，当调用字符串的indexOf()方法时，会从当前字符串的开始位置搜索s的位置；如果没有检索到字符串s，该方法返回-1 String str =&quot;We are students&quot;; int size = str.indexOf(&quot;a&quot;); // 变量size的值是3 2、lastIndexOf(String str) 该方法用于返回字符串最后一次出现的索引位置。当调用字符串的lastIndexOf()方法时，会从当前字符串的开始位置检索参数字符串str，并将最后一次出现str的索引位置返回。如果没有检索到字符串str，该方法返回-1. 如果lastIndexOf方法中的参数是空字符串&quot;&quot; ，，则返回的结果与length方法的返回结果相同。 获取指定索引位置的字符 使用charAt()方法可将指定索引处的字符返回。 String str = &quot;hello word&quot;; char mychar = str.charAt(4); // mychar的结果是o 获取子字符串 通过String类的substring()方法可对字符串进行截取。这些方法的共同点就是都利用字符串的下标进行截取，且应明确字符串下标是从0开始的。在字符串中空格占用一个索引位置。 1、substring(int beginIndex) 该方法返回的是从指定的索引位置开始截取知道该字符串结尾的子串。 String str = &quot;Hello word&quot;; String substr = str.substring(3); //获取字符串，此时substr值为lo word 2、substring(int beginIndex, int endIndex) beginIndex : 开始截取子字符串的索引位置 endIndex：子字符串在整个字符串中的结束位置 String str = &quot;Hello word&quot;; String substr = str.substring(0,3); //substr的值为hel 去除空格、标点等 trim() 方法返回字符串的副本，忽略前导空格和尾部空格。 public static void main(String[] args) { //string去除空格 String str=&quot; hello world &quot;; System.out.println(str); String str1=str.trim();//去除首尾空格 System.out.println(str1); String str2=str.replace(&quot; &quot;,&quot;&quot;);//去掉所有空格,包括首尾,中间 System.out.println(str2); String str3=str.replaceAll(&quot; +&quot;,&quot;&quot;);//去掉所有空格,包括首尾,中间 System.out.println(str3); String str4=str.replaceAll(&quot;\\\\s*&quot;,&quot;&quot;); //可以替换大部分空白字符， 不限于空格 . 说明:\\s 可以匹配空格、制表符、换页符等空白字符的其中任意一个 System.out.println(str4); //string去除标点符号 //正则表达式去除标点 String stri=&quot;ss&amp;*(,.~1如果@&amp;(^-自己!!知道`什`么#是$苦%……Z，&amp;那*()么一-=定——+告诉::;\\&quot;'/?.,&gt;&lt;[]{}\\\\||别人什么是甜。&quot;; System.out.println(stri); String stri1=stri.replaceAll(&quot;\\\\p{Punct}&quot;,&quot;&quot;);//不能完全清除标点 System.out.println(stri1); String stri2=stri.replaceAll(&quot;\\\\pP&quot;,&quot;&quot;);//完全清除标点 System.out.println(stri2); String stri3=stri.replaceAll(&quot;\\\\p{P}&quot;,&quot;&quot;);//同上,一样的功能 System.out.println(stri3); String stri4=stri.replaceAll(&quot;[\\\\pP\\\\p{Punct}]&quot;,&quot;&quot;);//清除所有符号,只留下字母 数字 汉字 共3类. System.out.println(stri4); } } //**效果如下** hello world hello world helloworld helloworld helloworld ss&amp;*(,.~1如果@&amp;(^-自己!!知道`什`么#是$苦%……Z，&amp;那*()么一-=定——+告诉::;&quot;'/?.,&gt;&lt;[]{}\\||别人什么是甜。 ss1如果自己知道什么是苦……Z，那么一定——告诉别人什么是甜。 ss~1如果^自己知道`什`么是$苦Z那么一=定+告诉&gt;&lt;||别人什么是甜 ss~1如果^自己知道`什`么是$苦Z那么一=定+告诉&gt;&lt;||别人什么是甜 ss1如果自己知道什么是苦Z那么一定告诉别人什么是甜 字符串替换 replace(w) 方法可实现将指定的字符或字符串替换成新的字符或字符串 oldChar：要替换的字符或字符串 newChar：用于替换原来字符串的内容 如果要替换的字符oldChar在字符串中重复出现多次，replace()方法会将所有oldChar全部替换成newChar。需要注意的是，要替换的字符oldChar的大小写要与原字符串中字符的大小写保持一致。 String str= &quot;address&quot;; String newstr = str.replace(&quot;a&quot;, &quot;A&quot;);// newstr的值为Address 判断字符串的开始与结尾 startsWith()方法与endsWith()方法分别用于判断字符串是否以指定的内容开始或结束。这两个方法的返回值都为boolean类型。 1、startsWith(String prefix) 该方法用于判断当前字符串对象的前缀是否是参数指定的字符串。 2、endsWith(String suffix) 该方法用于判断当前字符串是否以给定的子字符串结束 判断字符串是否相等 1、equals(String otherstr) 如果两个字符串具有相同的字符和长度，则使用equals()方法比较时，返回true。同时equals()方法比较时区分大小写。 2、equalsIgnoreCase(String otherstr) equalsIgnoreCase()方法与equals()类型，不过在比较时忽略了大小写。 按字典顺序比较两个字符串 compareTo()方法为按字典顺序比较两个字符串，该比较基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果按字典顺序此String对象位于参数字符串之前，则比较结果为一个负整数；如果按字典顺序此String对象位于参数字符串之后，则比较结果为一个正整数；如果这两个字符串相等，则结果为0. str.compareTo(String otherstr); 字母大小写转换 字符串的toLowerCase()方法可将字符串中的所有字符从大写字母改写为小写字母，而tuUpperCase()方法可将字符串中的小写字母改写为大写字母。 str.toLowerCase(); str.toUpperCase(); 字符串分割 使用split()方法可以使字符串按指定的分隔字符或字符串对内容进行分割，并将分割后的结果存放在字符数组中。 1 str.split(String sign); sign为分割字符串的分割符，也可以使用正则表达式。 没有统一的对字符串进行分割的符号，如果想定义多个分割符，可使用符号“|”。例如，“,|=”表示分割符分别为“,”和“=”。 str.split(String sign, in limit); 该方法可根据给定的分割符对字符串进行拆分，并限定拆分的次数。 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/java-zi-fu-chuan-chang-yong-lei/"},{"title":"Java 关于链表的基本算法","content":"算法代码记录 import java.util.HashMap; import java.util.Scanner; import java.util.Stack; /** * * @author smartBBer * 关于java中链表的操作 * 1. 求单链表中结点的个数: getListLength * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode * 4. 查找单链表的中间结点: getMiddleNode * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入） * 8. 判断一个单链表中是否有环: hasCycle * 9. 判断两个单链表是否相交: isIntersect * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode */ public class LinkedListSummary { /** * @param args * */ public static class Node{ int value; Node next; public Node(int n){ this.value=n; this.next=null; } } public static void main(String[] args) { // TODO Auto-generated method stub Scanner in=new Scanner(System.in); Node head=null; if(in.hasNextInt()){ head=new Node(in.nextInt()); } Node temp=head; while(in.hasNextInt()){ temp.next=new Node(in.nextInt()); temp=temp.next; } in.close(); //int len=getListLength(head); //Node reHead=reverseList(head); //reHead=reverseListRec(reHead); //Node node_k=reGetKthNode(head,3); //Node mid=getMiddleNode(head); //reversePrintListRec(head); //reversePrintListStack(head); //Node mergeHead=mergeSortedList(head,null); //Node sortHead=listSort(head); } //求单链表中结点的个数: getListLength public static int getListLength(Node head){ int len=0; while(head!=null){ len++; head=head.next; } return len; } //将单链表反转,循环 public static Node reverseList(Node head){ if(head==null||head.next==null)return head; Node pre=null; Node nex=null; while(head!=null){ nex=head.next; head.next=pre; pre=head; head=nex; } return pre; } //将单链表反转,递归 public static Node reverseListRec(Node head){ if(head==null||head.next==null)return head; Node reHead=reverseListRec(head.next); head.next.next=head; head.next=null; return reHead; } //查找单链表中的倒数第K个结点（k &gt; 0） public static Node reGetKthNode(Node head,int k){ if(head==null)return head; int len=getListLength(head); if(k&gt;len)return null; Node target=head; Node nexk=head; for(int i=0;i&lt;k;i++){ nexk=nexk.next; } while(nexk!=null){ target=target.next; nexk=nexk.next; } return target; } //查找单链表的中间结点 public static Node getMiddleNode(Node head){ if(head==null||head.next==null)return head; Node target=head; Node temp=head; while(temp!=null&amp;&amp;temp.next!=null){ target=target.next; temp=temp.next.next; } return target; } //从尾到头打印单链表,递归 public static void reversePrintListRec(Node head){ if(head==null)return; else{ reversePrintListRec(head.next); System.out.println(head.value); } } //从尾到头打印单链表,栈 public static void reversePrintListStack(Node head){ Stack&lt;Node&gt; s=new Stack&lt;Node&gt;(); while(head!=null){ s.push(head); head=head.next; } while(!s.isEmpty()){ System.out.println(s.pop().value); } } //合并两个有序的单链表head1和head2，循环 public static Node mergeSortedList(Node head1,Node head2){ if(head1==null)return head2; if(head2==null)return head1; Node target=null; if(head1.value&gt;head2.value){ target=head2; head2=head2.next; } else{ target=head1; head1=head1.next; } target.next=null; Node mergeHead=target; while(head1!=null &amp;&amp; head2!=null){ if(head1.value&gt;head2.value){ target.next=head2; head2=head2.next; } else{ target.next=head1; head1=head1.next; } target=target.next; target.next=null; } if(head1==null)target.next=head2; else target.next=head1; return mergeHead; } //合并两个有序的单链表head1和head2，递归 public static Node mergeSortedListRec(Node head1,Node head2){ if(head1==null)return head2; if(head2==null)return head1; if(head1.value&gt;head2.value){ head2.next=mergeSortedListRec(head2.next,head1); return head2; } else{ head1.next=mergeSortedListRec(head1.next,head2); return head1; } } //对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出 public static Node listSort(Node head){ Node nex=null; if(head==null||head.next==null)return head; else if(head.next.next==null){ nex=head.next; head.next=null; } else{ Node mid=getMiddleNode(head); nex=mid.next; mid.next=null; } return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归 } //对单链表进行排序,插入排序 public Node insertionSortList(Node head) { if(head==null||head.next==null)return head; Node pnex=head.next; Node pnex_nex=null; head.next=null; while(pnex!=null){ pnex_nex=pnex.next; Node temp=head; Node temp_pre=null; while(temp!=null){ if(temp.value&gt;pnex.value)break; temp_pre=temp; temp=temp.next; } if(temp_pre==null){ head=pnex; pnex.next=temp; } else{ temp_pre.next=pnex; pnex.next=temp; } pnex=pnex_nex; } return head; } //判断一个单链表中是否有环,快慢指针 public static boolean hasCycle(Node head){ boolean flag=false; Node p1=head; Node p2=head; while(p1!=null&amp;&amp;p2!=null){ p1=p1.next; p2=p2.next.next; if(p2==p1){ flag=true; break; } } return flag; } //判断两个单链表是否相交,如果相交返回第一个节点，否则返回null //如果单纯的判断是否相交，只需要看最后一个指针是否相等 public static Node isIntersect(Node head1,Node head2){ Node target=null; if(head1==null||head2==null)return target; int len1=getListLength(head1); int len2=getListLength(head2); if(len1&gt;=len2){ for(int i=0;i&lt;len1-len2;i++){ head1=head1.next; } }else{ for(int i=0;i&lt;len2-len1;i++){ head2=head2.next; } } while(head1!=null&amp;&amp;head2!=null){ if(head1==head2){ target=head1; break; } else{ head1=head1.next; head2=head2.next; } } return target; } //已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高 public static Node getFirstNodeInCycleHashMap(Node head){ Node target=null; HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;(); while(head!=null){ if(map.containsKey(head)) { target=head; break; } else{ map.put(head, true); } head=head.next; } return target; } //已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap //用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等 public static Node getFirstNodeInCycle(Node head){ Node fast=head; Node slow=head; while(fast!=null&amp;&amp;fast.next!=null){ slow=slow.next; fast=fast.next.next; if(slow==fast) break; } if(fast==null||fast.next==null)return null;//判断是否包含环 //相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等 slow=head; while(slow!=fast){ slow=slow.next; fast=fast.next; }//同步走 return slow; } //给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete //可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1) public static void deleteNode(Node head,Node delete){ //首先处理delete节点为最后一个节点的情况 if(delete==null)return; if(delete.next==null){ if(head==delete)head=null; else{ Node temp=head; while(temp.next!=delete){ temp=temp.next; } temp.next=null; } } else{ delete.value=delete.next.value; delete.next=delete.next.next; } return; } } 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/java-guan-yu-lian-biao-de-ji-ben-suan-fa/"},{"title":"Java 关于链表的基本算法","content":"算法代码记录 import java.util.HashMap; import java.util.Scanner; import java.util.Stack; /** * * @author smartBBer * 关于java中链表的操作 * 1. 求单链表中结点的个数: getListLength * 2. 将单链表反转: reverseList（遍历），reverseListRec（递归） * 3. 查找单链表中的倒数第K个结点（k &gt; 0）: reGetKthNode * 4. 查找单链表的中间结点: getMiddleNode * 5. 从尾到头打印单链表: reversePrintListStack，reversePrintListRec（递归） * 6. 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序: mergeSortedList, mergeSortedListRec * 7. 对单链表进行排序,listSort（归并）,insertionSortList（插入） * 8. 判断一个单链表中是否有环: hasCycle * 9. 判断两个单链表是否相交: isIntersect * 10. 已知一个单链表中存在环，求进入环中的第一个节点: getFirstNodeInCycle, getFirstNodeInCycleHashMap * 11. 给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete: deleteNode */ public class LinkedListSummary { /** * @param args * */ public static class Node{ int value; Node next; public Node(int n){ this.value=n; this.next=null; } } public static void main(String[] args) { // TODO Auto-generated method stub Scanner in=new Scanner(System.in); Node head=null; if(in.hasNextInt()){ head=new Node(in.nextInt()); } Node temp=head; while(in.hasNextInt()){ temp.next=new Node(in.nextInt()); temp=temp.next; } in.close(); //int len=getListLength(head); //Node reHead=reverseList(head); //reHead=reverseListRec(reHead); //Node node_k=reGetKthNode(head,3); //Node mid=getMiddleNode(head); //reversePrintListRec(head); //reversePrintListStack(head); //Node mergeHead=mergeSortedList(head,null); //Node sortHead=listSort(head); } //求单链表中结点的个数: getListLength public static int getListLength(Node head){ int len=0; while(head!=null){ len++; head=head.next; } return len; } //将单链表反转,循环 public static Node reverseList(Node head){ if(head==null||head.next==null)return head; Node pre=null; Node nex=null; while(head!=null){ nex=head.next; head.next=pre; pre=head; head=nex; } return pre; } //将单链表反转,递归 public static Node reverseListRec(Node head){ if(head==null||head.next==null)return head; Node reHead=reverseListRec(head.next); head.next.next=head; head.next=null; return reHead; } //查找单链表中的倒数第K个结点（k &gt; 0） public static Node reGetKthNode(Node head,int k){ if(head==null)return head; int len=getListLength(head); if(k&gt;len)return null; Node target=head; Node nexk=head; for(int i=0;i&lt;k;i++){ nexk=nexk.next; } while(nexk!=null){ target=target.next; nexk=nexk.next; } return target; } //查找单链表的中间结点 public static Node getMiddleNode(Node head){ if(head==null||head.next==null)return head; Node target=head; Node temp=head; while(temp!=null&amp;&amp;temp.next!=null){ target=target.next; temp=temp.next.next; } return target; } //从尾到头打印单链表,递归 public static void reversePrintListRec(Node head){ if(head==null)return; else{ reversePrintListRec(head.next); System.out.println(head.value); } } //从尾到头打印单链表,栈 public static void reversePrintListStack(Node head){ Stack&lt;Node&gt; s=new Stack&lt;Node&gt;(); while(head!=null){ s.push(head); head=head.next; } while(!s.isEmpty()){ System.out.println(s.pop().value); } } //合并两个有序的单链表head1和head2，循环 public static Node mergeSortedList(Node head1,Node head2){ if(head1==null)return head2; if(head2==null)return head1; Node target=null; if(head1.value&gt;head2.value){ target=head2; head2=head2.next; } else{ target=head1; head1=head1.next; } target.next=null; Node mergeHead=target; while(head1!=null &amp;&amp; head2!=null){ if(head1.value&gt;head2.value){ target.next=head2; head2=head2.next; } else{ target.next=head1; head1=head1.next; } target=target.next; target.next=null; } if(head1==null)target.next=head2; else target.next=head1; return mergeHead; } //合并两个有序的单链表head1和head2，递归 public static Node mergeSortedListRec(Node head1,Node head2){ if(head1==null)return head2; if(head2==null)return head1; if(head1.value&gt;head2.value){ head2.next=mergeSortedListRec(head2.next,head1); return head2; } else{ head1.next=mergeSortedListRec(head1.next,head2); return head1; } } //对单链表进行排序,归并排序,在排序里面不建议选用递归的合并有序链表算法，如果链表长度较长，很容易出现栈溢出 public static Node listSort(Node head){ Node nex=null; if(head==null||head.next==null)return head; else if(head.next.next==null){ nex=head.next; head.next=null; } else{ Node mid=getMiddleNode(head); nex=mid.next; mid.next=null; } return mergeSortedList(listSort(head),listSort(nex));//合并两个有序链表，不建议递归 } //对单链表进行排序,插入排序 public Node insertionSortList(Node head) { if(head==null||head.next==null)return head; Node pnex=head.next; Node pnex_nex=null; head.next=null; while(pnex!=null){ pnex_nex=pnex.next; Node temp=head; Node temp_pre=null; while(temp!=null){ if(temp.value&gt;pnex.value)break; temp_pre=temp; temp=temp.next; } if(temp_pre==null){ head=pnex; pnex.next=temp; } else{ temp_pre.next=pnex; pnex.next=temp; } pnex=pnex_nex; } return head; } //判断一个单链表中是否有环,快慢指针 public static boolean hasCycle(Node head){ boolean flag=false; Node p1=head; Node p2=head; while(p1!=null&amp;&amp;p2!=null){ p1=p1.next; p2=p2.next.next; if(p2==p1){ flag=true; break; } } return flag; } //判断两个单链表是否相交,如果相交返回第一个节点，否则返回null //如果单纯的判断是否相交，只需要看最后一个指针是否相等 public static Node isIntersect(Node head1,Node head2){ Node target=null; if(head1==null||head2==null)return target; int len1=getListLength(head1); int len2=getListLength(head2); if(len1&gt;=len2){ for(int i=0;i&lt;len1-len2;i++){ head1=head1.next; } }else{ for(int i=0;i&lt;len2-len1;i++){ head2=head2.next; } } while(head1!=null&amp;&amp;head2!=null){ if(head1==head2){ target=head1; break; } else{ head1=head1.next; head2=head2.next; } } return target; } //已知一个单链表中存在环，求进入环中的第一个节点,利用hashmap，不要用ArrayList，因为判断ArrayList是否包含某个元素的效率不高 public static Node getFirstNodeInCycleHashMap(Node head){ Node target=null; HashMap&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;(); while(head!=null){ if(map.containsKey(head)) { target=head; break; } else{ map.put(head, true); } head=head.next; } return target; } //已知一个单链表中存在环，求进入环中的第一个节点,不用hashmap //用快慢指针，与判断一个单链表中是否有环一样，找到快慢指针第一次相交的节点，此时这个节点距离环开始节点的长度和链表投距离环开始的节点的长度相等 public static Node getFirstNodeInCycle(Node head){ Node fast=head; Node slow=head; while(fast!=null&amp;&amp;fast.next!=null){ slow=slow.next; fast=fast.next.next; if(slow==fast) break; } if(fast==null||fast.next==null)return null;//判断是否包含环 //相遇节点距离环开始节点的长度和链表投距离环开始的节点的长度相等 slow=head; while(slow!=fast){ slow=slow.next; fast=fast.next; }//同步走 return slow; } //给出一单链表头指针head和一节点指针delete，O(1)时间复杂度删除节点delete //可惜采用将delete节点value值与它下个节点的值互换的方法，但是如果delete是最后一个节点，则不行，但是总得复杂度还是O(1) public static void deleteNode(Node head,Node delete){ //首先处理delete节点为最后一个节点的情况 if(delete==null)return; if(delete.next==null){ if(head==delete)head=null; else{ Node temp=head; while(temp.next!=delete){ temp=temp.next; } temp.next=null; } } else{ delete.value=delete.next.value; delete.next=delete.next.next; } return; } } 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/java-suan-fa/"},{"title":"Eclipse 调教","content":"版本对比 如果不知道安装什么版本，可以选择 Java EE 版本安装。 常用配置设置 以下为梓涵自用配置设置，可供参考。 设置 UTF-8 编码 设置 UTF-8 编码方式，中文才可以正常显示。 window -&gt; preferences -&gt; General -&gt; workspace中text file encoding改为utf-8 设置国际化资源编码 设置properties文件编码。 window -&gt; preferences -&gt; General -&gt; Content Types —&gt; Text —&gt; Java Properties File选中，然后下面default encoding改为 utf-8 设置jsp编码 设置为 UTF-8 编码，不然显示页面可能出现乱码。 window -&gt; preferences -&gt; web -&gt; jsp files中 encoding 改为 utf-8 优化文本编辑器显示 让界面交互更直观。 显示行号，显示空白字符 window -&gt; preferences -&gt; General -&gt; editor -&gt; text editors -&gt; show line numbers show whitespace characters ，然后点击configure visibility 设置如下图。 调整编辑器字体和大小 window -&gt; preferences -&gt; General -&gt; appearance -&gt; colors and fonts，在点开 Basic 、 Java 等下，找到 Text Font 字样，在选择 Edit 进行调整。 设置java默认风格每行最大字符数量 在使用ctrl + shift + f格式化java代码时，经常会遇到换行的问题，默认风格一行最大为80个字符， window -&gt; preferences -&gt; java -&gt; code style -&gt; formatter -&gt; edit... -&gt; line wrapping -&gt; maximum line width 可以根据需要修改. 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/eclipse-diao-jiao/"},{"title":"Java indexOf()实现","content":"代码记录 indexOf源码解析 public int indexOf(String str) { return indexOf(str, 0); } public int indexOf(String str, int fromIndex) { return indexOf(value, 0, value.length,str.value, 0, str.value.length, fromIndex); } static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { //1、当开始查找位置 大于等于 源字符串长度时,如果[查找字符串]为空,则: //返回字符串的长度,否则返回-1. if (fromIndex &gt;= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } //2、如果fromIndex 小于 0,则从 0开始查找。 if (fromIndex &lt; 0) { fromIndex = 0; } //3、如果[查找字符串]为空,则返回fromIndex if (targetCount == 0) { return fromIndex; } //4、开始查找,从[查找字符串]中得到第一个字符,标记为first char first = target[targetOffset]; //4.1、计算[源字符串最大长度] int max = sourceOffset + (sourceCount - targetCount); //4.2、遍历查找 for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { //4.2.1、从[源字符串]中,查找到第一个匹配到[目标字符串]first的位置 //for循环中,增加while循环 /* Look for first character. */ if (source[i] != first) { while (++i &lt;= max &amp;&amp; source[i] != first); } //4.2.2、如果在[源字符串]中,找到首个[目标字符串], //则匹配是否等于[目标字符串] /* Found first character, now look at the rest of v2 */ if (i &lt;= max) { //4.2.2.1、得到下一个要匹配的位置,标记为j int j = i + 1; //4.2.2.2、得到其余[目标字符串]的长度,标记为end int end = j + targetCount - 1; //4.2.2.3、遍历,其余[目标字符串],从k开始, //如果j不越界(小于end,表示:其余[目标字符串]的范围), //同时[源字符串]==[目标字符串],则 //自增,继续查找匹配。j++、k++ for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); //4.2.2.4、如果j与end相等,则表示: //源字符串中匹配到目标字符串,匹配结束,返回i。 if (j == end) { /* Found whole string. */ return i - sourceOffset; } } } //其余情况,返回-1.return -1; return -1; } 实现 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 public int strStr(String haystack, String needle) { if(needle.length() == 0) { //当noodle为空应该返回0 return 0; } else if(needle.length() &gt; haystack.length()) { //当needle长度大于haystack，返回-1 return -1; } else { char first = needle.charAt(0); int max = haystack.length() - needle.length(); for(int i = 0; i &lt;= max; i++) { if(haystack.charAt(i) != first) { while(++i &lt;= max &amp;&amp; haystack.charAt(i) != first); } if(i &lt;= max) { int j = i + 1; int end = j + needle.length() - 1; for(int k = 1; j &lt; end &amp;&amp; haystack.charAt(j) == needle.charAt(k); j++, k++); if(j == end) { return i; } } } return -1; } } public int strStr2(String haystack, String needle) { if(needle.equals(&quot;&quot;)||haystack.equals(needle)){ return 0; } int index=-1; if(haystack.contains(needle)){ String[] str=haystack.split(needle); if(str.length&gt;=1){ index=str[0].length(); }else { index=0; } }else{ index=-1; } return index; } 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/java-indexof/"},{"title":"Java框架总结","content":"Java框架总结 使用SpringMVC + Spring + Mybatis （SSM）框架 使用Struts2 + Spring + Hibernate （SSH）框架 相当于 页面 -&gt; Servlet -&gt; Java（接口类） -&gt; JDBC -&gt; 数据库 SpringPost 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/java-zong-jie/"},{"title":"Web前端助手(FeHelper)","content":"Web前端助手(FeHelper) 获取地址： Chrome扩展商城 国内地址 安装方法 Chrome扩展商城下载不需要看此方法。 下载当前最新版*.crx； chrome浏览器地址栏输入：chrome://extensions/ 并打开； 右上角开启开发者模式； 拖拽crx到当前页面，完成安装。 功能简介 FeHelper--弹出菜单 插件入口，点击ICON，插件相关的所有功能都会在这里列出来，在popup中选择所需使用的功能即可使用 JSON接口自动格式化查看 当你访问的接口（打开的页面）返回的是一个JSON格式的数据，FeHelper会自动将内容进行格式化处理，便于您的查看 JSON查看器 把你的JSON代码粘贴到JSON查看器的输入框中，点击“格式化”，在下方便会以非常友好的方式列出JSON数据，便于查看 代码美化 包括Javascript代码美化、CSS代码美化、HTML代码美化；其实所有C系的代码，都可以通过Javascript代码美化工具进行格式化查看 代码压缩 包括Web前端Javascript代码压缩、CSS代码压缩、HTML代码压缩 字符串编解码 包括Unicode编码和解码、UTF-8字符串编码和解码、Base64字符串编解码、字符串MD5编码，前端非常实用的工具 图片Base64编码 对图片文件进行base64编码，直接拷贝datauri格式的数据 二维码生成器 能对网址、普通文本内容、电话号码、通讯录、短信等编码并生成二维码，很实用的二维码生成工具 二维码解码 针对网页上的二维码，点击右键，选择【二维码解码】，可在当前页面直接看到解码结果！ 全网页截图 针对整个网页进行滚动截屏，在新窗口可预览后再手动保存 时间（戳）转换工具 支持任意时间到对应时间戳的转换；支持任意时间戳到对应日期的转换 正则表达式工具 提供一个正则表达式的及时测试工具，并能将匹配结果进行高亮显示、高亮定位等；同时还罗列了一些常用的正则表达式供开发者使用 页面取色工具 提供一个网页取色的工具，任意页面均可使用，方便大家在开发过程中能精准获取某元素的颜色值，再也不用截图后再通过Photoshop取色了 编码规范检测 对当前网页进行Javascript、CSS、HTML编码规范的检测，包括文件是否压缩、标签是否正确闭合、cookie管理等等 页面性能检测 对当前页面的性能进行检测，如HTTP响应时间、页面渲染时间、是否启用gzip压缩等等 FeHelper配置页 在这里，你可以随意定制属于你自己的FeHelper常用功能！ 关注我的微信公众号 ","link":"https://tooyi.github.io/post/web-fehelper/"},{"title":"Visual Studio Code 使用技巧","content":"Visual Studio Code 使用技巧 一窗口打开多项目 文件 -&gt; 将文件添加到工作区 添加多个文件项目即可 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/visual-studio-code/"},{"title":"Visual Studio Code 主题及插件推荐","content":"Visual Studio Code 主题及插件推荐 主题 One Dark Pro Atom One Dark Theme Eva Theme 插件 CSS Peek： html和css中关联css的跳转 快捷键 F12：跳转 css 文件，jump directly to the css file or open it in a new editor Ctrl+Shift+F12： load the css file inline and make quick edits right there. Ctrl+hover：show the definition in a hover over the symbol ","link":"https://tooyi.github.io/post/visual-studio/"},{"title":"微信小程序开发","content":"微信小程序开发 小程序文档 注册账号、代码构成、小程序上线等请参考官方文档 IDE选择 官方开发工具 VScode + wept Egret Wing 环境 简述 代码高亮 代码提示 调试 实时预览 软件/插件下载 官方工具 微信小程序官方工具 支持 极其弱 支持 支持 软件 Egret Wing 首款支持微信小程序开发的IDE 支持 支持 支持 支持 软件 VScode + wept 插件作者已不在维护 支持 支持 支持 支持 插件 Sublime Text 3 代码编辑器，需要安装插件 支持 支持 不支持 不支持 插件 WebStorm 重量级IDE 支持 支持 不支持 不支持 插件 小程序组件 Weui WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web 开发量身设计，可以令用户的使用感知更加统一。包含 button、cell、dialog、 progress、 toast、article、actionsheet、icon 等各式元素。 GitHub 地址：Weui 演示：https://weui.io wx-charts 微信小程序图表工具，charts for WeChat small app 基于 canvas 绘制，体积小巧 GitHub 地址：wx-charts wemark 微信小程序 Markdown 渲染库 用于在小程序中渲染 Markdown 文本。 在小程序诞生之前，Markdown 的渲染一般需要解析成HTML，然后渲染解析后的 HTML。然而小程序并没有提供 HTML 渲染的功能，因此在 wemark 诞生之前，几乎所有的 Markdown 渲染库全部无法在小程序下正常工作。 wemark可以实现在小程序下渲染Markdown内容，支持图片、表格在内的大部分Markdown特性。 WeZRender 微信小程序 Canvas 开发 使用 ZRender 实现 ZRender 是二维绘图引擎，它提供 Canvas、SVG、VML 等多种渲染方式。ZRender 也是 ECharts 的渲染器。 GitHub 地址：ZRender 实现 使用 ECharts 实现 ECharts 是使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器，底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。 GitHub地址：ECharts 实现 WeToast WeToast 是仿照微信小程序提供的 showToast 功能，提供视觉一致的增强插件，弥补小程序showToast功能上的不足（如只能显示 success、loading 两种 icon ，且 icon 不可去除，持续时间最大10秒等）。 GitHub 地址：WeToast wxapp-charts 微信小程序图表charts组件 WeiXinProject 微信小程序实现--列表的上拉刷新和上拉加载 GitHub 地址：WeiXinProject citySelect 基于微信小程序的城市选择 小程序框架 Wepy 微信小程序组件化开发框架 通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async Functions的引入都是为了能让开发小程序项目变得更加简单，高效。 GitHub 地址：Wepy 体验：https://tencent.github.io/wepy/ Labrador 微信小程序组件化开发框架 GitHub 地址：Labrador wxapp-devFrame 小程序基本的开发框架抽取 GitHub 地址：wxapp-devFrame Westore 受 Omi 框架 的启发，且专门为小程序开发的 JSON Diff 库，所以有了 westore 全局状态管理和跨页通讯框架让一切尽在掌握中，且受高性能 JSON Diff 库的利好，长列表滚动加载显示变得轻松可驾驭。总结下来有如下特性和优势: 和 Omi 同样简洁的 Store API 超小的代码尺寸(包括 json diff 共100多行) 尊重且顺从小程序的设计(其他转译库相当于反其道行) this.update 比原生 setData 的性能更优，更加智能 GitHub地址：westore 库 wxParse wxParse-微信小程序富文本解析自定义组件，支持HTML及markdown解析 GitHub 地址：wxParse wechat-weapp-redux 微信小程序 Redux 绑定，用于在微信小程序为页面绑定 Redux Store。 代码是基于 react-redux 修改的 GitHub 地址：wechat-weapp-redux wilddog-weapp 野狗微信小程序客户SDK 野狗是什么? 野狗科技(北京)有限公司（简称：野狗）是安全可靠的实时通信云。野狗为企业和开发者提供了可编程的实时数据、音视频通信能力，以及短信服务，可以安全地构建丰富场景化的实时通信业务。 GitHub 地址：wilddog-weapp wafer-client-sdk 本项目是 Wafer 的组成部分，为小程序客户端开发提供 SDK 支持会话服务和信道服务。 GitHub 地址：wafer-client-sdk WxNotificationCenter 微信小程序通知广播模式类,降低小程序之间的耦合度 GitHub 地址：WxNotificationCenter 欢迎关注我的微信公众号 ","link":"https://tooyi.github.io/post/wechat3/"},{"title":"下载微信图文中的视频","content":"下载微信图文中的视频 摘要 在有的时候我们需要下载公众号中的视频，那么我们怎么才能下载呢？在网上搜索了下，发现很多都是抓包获取的，没有好的方法，干脆就自己动手了。 动手 首先得明白，微信图文中的视频都是挂在腾讯视频上的，所以视频的 url 肯定是以 v.qq.com 开头的； 用浏览器打开微信图文，这里使用的是 Chrome 浏览器； 查看源码，点击鼠标右键，选择查看源码； 搜索关键字，Ctrl + F ，输入 v.qq.com ，即可找到视频的 url 地址； https://v.qq.com/iframe/preview.html?vid=z0191d2jue3&amp;amp;width=500&amp;amp;height=375&amp;amp;auto=0 复制视频 url 地址到新窗口打开，如下图 之后有两种方法将视频保存至本地 IDM下载 安装过 IDM 的，在浏览器中会有一个 IDM浮窗 很方便就可以下载，同时视频播放前的广告也会被 IDM 捕捉，下载时看清楚即可。 抓包 在之前的视频界面按 F12 打开浏览器的控制台，选择 Network ，播放视频，在右边栏找到视频地址即可。 http://ugcbsy.qq.com/uwMRJfz-r5jAYaQXGdGnC2_ppdhgmrDlPaRvaV7F2Ic/z0191d2jue3.mp4?vkey=1CF07F9A6D07BCB2FC5C39D356208A957BD7DEFCD45E02078B70734FC6CF286D021A589AA2D1ECD86F533A44981AF98A36C72DD27E408504D008FDC9552D50FC1D53DFA7BA9BD3D6328DD26D34869FD34F87778711FF8282ECB5AD5428FB21C91B0B15F28017F4F45867291B1BF43D30423A52A90E4A0180&amp;br=60&amp;platform=2&amp;fmt=auto&amp;level=0&amp;sdtfrom=v5010&amp;guid=f0902504c2c6838dddc832e651ea45bf 复制视频地址，至浏览器中打开，待视频显示出来点击鼠标右键保存即可。 ","link":"https://tooyi.github.io/post/wechat2/"},{"title":"小程序开发之app.json详解","content":"小程序开发之app.json详解 我们使用app.json文件来对微信小程序进行全局配置文件，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 切记，不要在真实项目中写注释，否则会报错，以下注释是为了更好的说明 { &quot;pages&quot;:[ //这个里边都是用来配置所需要用到的界面所在的文件路径，配置为第一行的是默认显示的页面。 &quot;pages/index/index&quot;, &quot;pages/--------/--------”, &quot;pages/--------/--------&quot;, &quot;pages/--------/-------&quot;//记住最后一行不要加逗号 ], &quot;window&quot;:{ //这个属性是用来配置界面的上边的标题栏的， &quot;backgroundTextStyle&quot;:&quot;light&quot;,//这个用来设置文本的风格。 &quot;navigationBarBackgroundColor&quot;: &quot;#0066CC&quot;,//这个是背景颜色，记住用这种颜色格式的，不要用七种颜色的英文单词（red,blue）等，不然不起效果 &quot;navigationBarTitleText&quot;: &quot;--------&quot;,//这个就是文字内容 &quot;navigationBarTextStyle&quot;:&quot;white&quot;//这个是文字的颜色。 }, &quot;tabBar&quot;: {//这个的话就是配置下边的菜单栏。 &quot;color&quot;: &quot;#0066CC&quot;,//这个是配置文字的颜色 &quot;selectedColor&quot;: &quot;#FF0033&quot;,//这个是配置选中某个菜单时文字的颜色。 &quot;borderStyle&quot;: &quot;#336699&quot;, &quot;backgroundColor&quot;: &quot;#99CC00&quot;,//这个是整个菜单栏的背景颜色 &quot;list&quot;: [//这个是列表，就是具体设置菜单栏 { &quot;text&quot;: &quot;-----&quot;,//文字 &quot;pagePath&quot;: &quot;pages/index/index&quot;,//就是对应到那个页面 &quot;iconPath&quot;: &quot;image/--------&quot;,//默认的图片 &quot;selectedIconPath&quot;: &quot;image/--------&quot;//选中以后显示的图片。 } --可以根据自己需要来加，tabBar至少需要两个--- ] } } ","link":"https://tooyi.github.io/post/wechat1/"},{"title":"学会高效率使用搜索引擎","content":"学会高效率使用搜索引擎 看了这篇文章，你将学会如何高效使用搜索引擎。有人说：现在 谁不会使用百度。咦~ 先别急着反驳我，接着往下看。 友情提示：看完此文，可能会颠覆你对搜索引擎的三观。 1. 『关键字』+『空格』+『减号』+『关键字』 减号表示搜索不包含减号后面的关键字，这样搜索可以去掉有关后面关键字的显示，如果想去掉一些不想看到的搜索结果可以使用这种搜索方式，但也有可能去掉了你想看到的内容（鬼知道你想看到的内容里有没有包含要去掉的关键字）。百度和谷歌都支持该指令。 这样的搜索方式也同样可以去广告，只要在关键字后面 +『空格』+『-广告』这样就可以嗒。 比如输入『茶 -百度百科』，如此可以去掉原有的百度百科条列。 注意：只有关键字『茶』和『减号』之间有空格，而『减号』与关键字『百度百科』之间没有空格，否则你可能会出现这种情况。 2. 『关键字』+『空格』+『site：网址』 site是SEO最熟悉的高级搜索指令，直接搜索该网址下的所有内容，相当于直接在该网址搜索内容，很方便，当然前提是你知道目标网址，比如淘宝，京东等。 比如输入：『茶 site：jd.com』 或者 『茶 site：taobao.com』，搜索结果就会直接出现该网址内的搜索内容，怎么样，很神奇吧。 3. 『关键字』+『空格』+『filetype：+doc/ppt等文件格式』 filetype用于搜索特定的文件格式，如doc、ppt格式等，百度和谷歌都支持filetype指令。 比如输入：『茶 filetype：ppt』或者『茶 filetype：doc』，这样搜索的结果就会显示对应的文档。 4. 『“』+『关键字』+『”』 把关键字放入双引号内表示完全匹配搜索，也就是说搜索结果返回的页面包含双引号内出现所有的内容，字出现的顺序也必须完全匹配的。百度和谷歌都支持该指令。 比如输入：『“茶之道”』，搜索返回的页面就会出现包含『茶之道』的相关内容。 5. 『inurl:』+『关键字』 inurl：指令用于搜索关键字出现在url中的页面，关键词支持中文和英文，百度和谷歌都支持该指令。 比如输入：『inurl：baidu』或者『inurl：百度』，搜索返回的页面都是一样的。 6. 『intitle:』+『关键字』 intitle：指令表示搜索结果返回页面是title中包含关键字的页面，也就是说搜索内容的标题含有关键字。百度和谷歌都支持该指令。 比如输入：『intitle:茶』 7. 『define:』+『关键字』 define：表示快速查询关键字意思，只有谷歌支持该指令，测试中百度不支持。 比如输入：『define:茶』，搜索返回的页面就会显示『茶』的意思。 8. 快速计算 地方有时候需要计算总是要打开计算机其实搜索引擎就直接可以算出答案。百度和谷歌都支持该指令。 比如输入：『123*90+21』，返回的结果是答案『11091』。 9. 单位换算 在需要单位换算的场景下，我们也可以使用搜索引擎来计算，只要输入换算的两种单位即可。百度和谷歌都支持该指令。 比如输入：『10cm = m』，返回的页面中会直接出现换算结果。 10. 快速查找『Ctrl』+『F』 最后一个无关搜索，但这是一个非常方便的页面查找功能。 比如在页面中查找『茶』，页面找那个的『茶』字就会以高亮的形式显示出来，方便查找。 好了，我总结的高效率搜索技巧全在这儿了，看完你感觉以前对搜索引擎了解多少呢？ 阅读原文 ","link":"https://tooyi.github.io/post/search-post/"},{"title":"记录 - 学习Git遇到的坑","content":"记录向，学习Git的填坑记录 学习Git遇到的坑 如果不明白文中指令含义，建议查看 Git 笔记整理 1. git commit 遇到 error：pathspec 原因：输入 git commit -m &quot;messages&quot; 时，忘记加 -u 。 2. git commit -am &quot;messages&quot; ，不能提交新增文件 先使用 git add -A ，提交全部新增文件，再使用 git commit -m &quot;messages&quot; 。 3. 有时候 git push origin master 会报错，如下： $ git push origin master To github.com:smartBBer/LeetCode.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to 'git@github.com:smartBBer/LeetCode.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 错误原因很简单：本地库和GitHub中的库不同步，解决办法有两种。 第一种解决方法(不要轻易使用) 加上 -f，强制推送上去，这时你的GitHub上的库会以本地同步， $ git push -f Enumerating objects: 35, done. Counting objects: 100% (35/35), done. Delta compression using up to 4 threads Compressing objects: 100% (24/24), done. Writing objects: 100% (35/35), 6.35 KiB | 325.00 KiB/s, done. Total 35 (delta 6), reused 6 (delta 1) remote: Resolving deltas: 100% (6/6), done. To github.com:smartBBer/LeetCode.git + 0794cc5...80639ea master -&gt; master (forced update) 第二种解决方法（推荐） 使用git pull --rebase origin master合并 GitHub 和 本地 的库，本地会多出之前不同步的文件，在使用 git push -u origin master 推送到 GitHub 库中。 $ git pull --rebase origin master $ git push origin master fatal: 'origin' does not appear to be a git repository fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决办法：重新输入一次：git remote add origin git@github.com:yourusername/test.git fatal: remote error: XXXXXX is not a valid repository name Email support@github.com for help 解决办法：使用git remote rm origin 然后再使用上传命令 4. 输入：git remote add origin git@github.com:yourName/yourRepo.git时 fatal: Not a git repository (or any of the parent directories): .git 解决办法：输入 git init ，初始化一个本地仓库 fatal: remote origin already exists. 解决办法： 1 删除Git仓库中的origin信息：git remote rm origin 2 重新添加Git仓库中的origin信息 5. 输入git add ./时 fatal: Not a git repository (or any of the parent directories): .git 解决办法：先输入git init，再add ","link":"https://tooyi.github.io/post/git-notes/"},{"title":"Git笔记整理","content":"笔记根据廖雪峰Git教程整理 Git笔记整理 Git简介 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git SVN和Git主要的区别在于历史版本维护的位置 Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。 这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 Git命令 Git配置 $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库 初始化一个Git仓库 $ git init 添加文件到Git仓库 包括两步： $ git add &lt;file&gt; $ git commit -m &quot;description&quot; git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态 $ git status 查看修改内容 $ git diff $ git diff --cached $ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别 查看提交日志 $ git log 简化日志输出信息 $ git log --pretty=oneline 查看命令历史 $ git reflog 版本回退 $ git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。 回退指定版本号 $ git reset --hard commit_id commit_id是版本号，是一个用SHA1计算出的序列 工作区、暂存区和版本库 工作区：在电脑里能看到的目录； 版本库：在工作区有一个隐藏目录.git，是Git的版本库。 Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。 进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支 撤销修改 丢弃工作区的修改 $ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区的修改 分两步： 第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区： $ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改 $ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件 $ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行 $ rm &lt;file&gt; $ git add &lt;file&gt; 进一步的解释 Q：比如执行了rm text.txt 误删了怎么恢复？ A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了 Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？ A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区 $ git reset head text.txt $ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？ A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库 创建SSH Key $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 关联远程仓库 $ git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库 $ git push -u origin master -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆 $ git clone https://github.com/usern/repositoryname.git 分支 创建分支 $ git branch &lt;branchname&gt; 查看分支 $ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支 $ git checkout &lt;branchname&gt; 创建+切换分支 $ git checkout -b &lt;branchname&gt; 合并某分支到当前分支 $ git merge &lt;branchname&gt; 删除分支 $ git branch -d &lt;branchname&gt; 查看分支合并图 $ git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支 $ git merge --no-ff -m &quot;description&quot; &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场 $ git stash 查看工作现场 $ git stash list 恢复工作现场 $ git stash pop 丢弃一个没有合并过的分支 $ git branch -D &lt;branchname&gt; 查看远程库信息 $ git remote -v 在本地创建和远程分支对应的分支 $ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联 $ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支 $ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交； 从远程抓取分支 $ git pull 如果有冲突，要先处理冲突。 标签 tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 新建一个标签 $ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 指定标签信息 $ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签 $ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。 查看所有标签 $ git tag 推送一个本地标签 $ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签 $ git push origin --tags 删除一个本地标签 $ git tag -d &lt;tagname&gt; 删除一个远程标签 $ git push origin :refs/tags/&lt;tagname&gt; ","link":"https://tooyi.github.io/post/git/"}]}